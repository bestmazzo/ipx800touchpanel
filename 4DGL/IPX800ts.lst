4DGL Compiler 2.6.0.5 -- Copyright 2004-2010 4D Labs
** Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts.4DG compiled Mon Jan  7 22:49:07 2013

file Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts.4DG

file C:\Programmi\4D Labs\4D Workshop 3 IDE\include\uLCD-32PT_GFX2.fnc

0001  0001             #platform "uLCD-32PT_GFX2"
0002  0001             #platform "uLCD-32PT_GFX2"
0003  0008             */
0004  0009                 #constant ULCD_32PT_GFX
0005  0009                 #constant ULCD_32PT_GFX
0006  0010   
0007  0011                 #IFNOT EXISTS PICASO_GFX2_FUNCTIONS
file C:\Programmi\4D Labs\4D Workshop 3 IDE\include\PicasoGFX2_Functions.fnc

0008  0012                     #inherit "PicasoGFX2_Functions.fnc"          // inherit the generic functions
0009  0012                     #inherit "PicasoGFX2_Functions.fnc"          // inherit the generic functions
0010  0001   
0011  0002             // Common inheritance for PicasoGFX2 platforms
0012  0003   
0013  0004             #constant PICASO_GFX_FUNCTIONS
0014  0004             #constant PICASO_GFX_FUNCTIONS
0015  0005   
0016  0006   
0017  0007             #CONST
0018  0017             #END
0019  0018   
0020  0019             #CONST
0021  0025             #END
0022  0026   
0023  0027   
0024  0028             #CONST
0025  0040             #END
0026  0041   
0027  0042   
0028  0043             #CONST
0029  0208             #END
0030  0209   
0031  0210   
0032  0211             // baud divisor rates for setbaud(n);
0033  0212             #CONST
0034  0234             #END
0035  0235   
0036  0236   
0037  0237   
0038  0238   
0039  0243             */
0040  0244   
0041  0245   
0042  0246             //==============================================//
0043  0247             // EVE bios functions                           //
0044  0248             //==============================================//
0045  0249                                                             //
0046  0250             func serin(), 1;                // read a byte from COM0
0047  0251             // Syntax: serin();
0048  0252             // Usage : char := serin();
0049  0253             // Notes : Receives a character from the Serial Port COM0. The transmission format is:
0050  0254             //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0051  0255             //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0052  0256             //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
0053  0257             //     : Returns: -1 if no character is available
0054  0258             //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
0055  0259             //     : Returns: positive value 0 to 255 for a valid character received
0056  0260   
0057  0261             func putch("char"), 0;                // write single char to current output device
0058  0262             // Syntax: putch("char");
0059  0263             // Usage : putch("A");
0060  0264             // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
0061  0265             //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
0062  0266             //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
0063  0267             //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
0064  0268             //     : The arguments can be a variable, array element, expression or constant
0065  0269   
0066  0270             func serout("char"), 0;                // write a byte to COM0
0067  0271             // Syntax: serout1("char");
0068  0272             // Usage : serout1(ch);
0069  0273             // Notes : send character to COM1
0070  0274   
0071  0275             func setbaud("baudnum"), 0;            // set baud rate of COM0
0072  0276             // Syntax: setbaud(baud_number);
0073  0277             // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
0074  0278             // *Notes : argument specifies the baud rate using pre-defined constant.
0075  0279             //       : The pre-defined constant is a value of 0-19 , and internally
0076  0280             //       : this is used as a table pointer to get the baud rate divisor
0077  0281             //       : value for one of the 20 selected baud rates, control is then
0078  0282             //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
0079  0283             //       : The pre-defined constants equate to a value of 0-19.
0080  0284             //       : If a value other than 0-19 is used, a run time error (eror 25)
0081  0285             //       : will occur.
0082  0286   
0083  0287             func to("device"), 1;                // output device redirection
0084  0288             // Syntax: to(outstream);
0085  0289             // Usage : to(APPEND); putstr("TWO ");
0086  0290             // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
0087  0291             //     :
0088  0292             //     : to() sends the printed output to destinations other than the screen. Normally, print just
0089  0293             //     : sends its output to the display in TEXT mode which is the default, however, the output from
0090  0294             //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
0091  0295             //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
0092  0296             //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
0093  0297             //     : completed its action. The APPEND argument is used to send the printed output to the same
0094  0298             //     : place as the previous redirection. This is most useful for building string arrays, or adding
0095  0299             //     : sequential data to a media stream.
0096  0300             //     :
0097  0301             //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
0098  0302             //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
0099  0303             //     :                            appended to user memory if previous redirection was to an array.
0100  0304             //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
0101  0305             //     : TEXT           0xFF08      Output is directed to the screen (default).
0102  0306             //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
0103  0307             //     : I2C            0xF820      Output is directed to the I2C port.
0104  0308             //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
0105  0309   
0106  0310   
0107  0311             func pause("milliseconds"), 0;            // blocking delay
0108  0312             // Syntax: pause(milliseconds);
0109  0313             // Usage : pause(1000);                //pause for 1 second
0110  0314             // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
0111  0315   
0112  0316             func putnum("arg1","arg2"), 1;            // print number to current output device
0113  0317             // Syntax: putnum(format, value);
0114  0318             // Usage : var := putnum(HEX, val);
0115  0319             // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
0116  0320             //     : Format: A constant that specifies the number format
0117  0321             //     : Value : The number to be printed
0118  0322             //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
0119  0323             //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
0120  0324             //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
0121  0325             //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
0122  0326             //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
0123  0327             //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
0124  0328             //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
0125  0329             //     :                                     BIN6     BIN6Z     BIN6ZB
0126  0330             //     :                                     BIN7     BIN7Z     BIN7ZB
0127  0331             //     :                                     BIN8     BIN8Z     BIN8ZB
0128  0332             //     :                                     BIN9     BIN9Z     BIN9ZB
0129  0333             //     :                                     BIN10     BIN10Z     BIN10ZB
0130  0334             //     :                                     BIN11     BIN11Z     BIN11ZB
0131  0335             //     :                                     BIN12     BIN12Z     BIN12ZB
0132  0336             //     :                                     BIN13     BIN13Z     BIN13ZB
0133  0337             //     :                                     BIN14     BIN14Z     BIN14ZB
0134  0338             //     :                                     BIN15     BIN15Z     BIN15ZB
0135  0339             //     :                                     BIN16     BIN16Z     BIN16ZB
0136  0340             //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
0137  0341             //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
0138  0342             //     : | | | | \___ ___/ \__ __/ \_____ _____/
0139  0343             //     : | | | | V V V
0140  0344             //     : | | | | | | |
0141  0345             //     : | | | | | |
0142  0346             //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
0143  0347             //     : | | | | digit count |
0144  0348             //     : | | | | |___reserved (not used on GOLDELOX)
0145  0349             //     : | | | |
0146  0350             //     : | | | |
0147  0351             //     : | | | |
0148  0352             //     : | | | |
0149  0353             //     : | | | |
0150  0354             //     : | | | |______ 1 = leading zeros included
0151  0355             //     : | | | 0 = leading zeros suppressed
0152  0356             //     : | | |
0153  0357             //     : | | |
0154  0358             //     : | | |_______ 1 = leading zero blanking
0155  0359             //     : | |
0156  0360             //     : | |_____ sign bit (0 = signed, 1 = unsigned)
0157  0361             //     : |
0158  0362             //     : |______ 1 = space before unsigned number
0159  0363   
0160  0364   
0161  0365             func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
0162  0366   
0163  0367             func putstr("string"), 1;                       // print string to current output device
0164  0368             // Syntax: putstr(pointer);
0165  0369             // Usage : putstr("HELLO\n");
0166  0370             // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
0167  0371             //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
0168  0372             //       : a data statement. Note that string constants and data statement pointers are byte aligned.
0169  0373             //       : The output of putstr can be redirected to the communications port, the media, or memory
0170  0374             //       : using the to(...); function.
0171  0375             //       : A string constant is automatically terminated with a zero.
0172  0376             //       : A string in a data statement is not automatically terminated with a zero.
0173  0377             //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
0174  0378             //       : element packs 1 or 2 characters.
0175  0379   
0176  0380   
0177  0381             func strlen("varAddress"), 1;                   // return length of a var packed string in character units
0178  0382             // Syntax: strlen("varAddress);
0179  0383             // Usage : strlen("HELLO\n");
0180  0384             // Notes : gives the length of a string that is packed into regular var array
0181  0385             //       : Use str_Length(ptr)  for string pointer mode
0182  0386   
0183  0387   
0184  0388             //==============================================//
0185  0389             // Memory Access Function Prototypes            //
0186  0390             //==============================================//
0187  0391                                                             //
0188  0392             func peekW("address"), 1;                       // read a word from system memory
0189  0393             func pokeW("address", "wordvalue"), 0;          // write a word to system memory
0190  0394             // refer to address map of internal variables   //
0191  0395             //==============================================//
0192  0396             // Math Functions                               //
0193  0397             //==============================================//
0194  0398                                                             //
0195  0399             func ABS("value"), 1;                           // return a positive number
0196  0400             // Syntax: ABS(value);
0197  0401             // Usage : var := ABS(arg);
0198  0402             // Notes : Returns the absolute value of an argument
0199  0403   
0200  0404             func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
0201  0405             // Syntax: MIN(value1, value2);
0202  0406             // Usage : var := MIN(arg1, arg2);
0203  0407             // Notes : Returns the minimum of 2 arguments
0204  0408   
0205  0409             func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
0206  0410             // Syntax: MAX(value1, value2);
0207  0411             // Usage : var := MAX(arg1, arg2);
0208  0412             // Notes : Returns the maximum of 2 arguments
0209  0413   
0210  0414             func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
0211  0415             // Syntax: SWAP(&var1, &var2);
0212  0416             // Usage : SWAP(&var1, &var2);
0213  0417             // Notes : Swaps the contents of 2 variables or memory locations
0214  0418   
0215  0419             func SIN("angle"), 1;                           // return SIN of angle
0216  0420             // Syntax: SIN(angle);
0217  0421             // Usage : var := SIN(arg);
0218  0422             // Notes : Returns the sine in radians of an argument in degrees
0219  0423             //       : the returned value range is from 127 to -127. The real
0220  0424             //       : cosine values vary from 1.0 to -1.0 so appropriate
0221  0425             //       : scaling must be done in user code.
0222  0426   
0223  0427             func COS("angle"), 1;                           // return COS of angle
0224  0428             // Syntax: COS(angle);
0225  0429             // Usage : var := COS(arg);
0226  0430             // Notes : Returns the cosine in radians of an argument in degrees
0227  0431             //       : the returned value range is from 127 to -127. The real
0228  0432             //       : cosine values vary from 1.0 to -1.0 so appropriate
0229  0433             //       : scaling must be done in user code.
0230  0434   
0231  0435             func RAND(), 1;                                 // return a pseudo random number
0232  0436             // Syntax: RAND();
0233  0437             // Usage : var := RAND();
0234  0438             // Notes : Returns a random number between 0 and 0xFFFF.
0235  0439             //       : The random number generator must first be seeded
0236  0440             //       : by using the SEED(number) function.
0237  0441   
0238  0442             func SEED("number"), 0;                         // re-seed the pseudo random number generator
0239  0443             // Syntax: SEED(number);
0240  0444             // Usage : SEED(arg);
0241  0445             // Notes : Seeds the random number generator.
0242  0446   
0243  0447             func OVF(), 1;                                  // returns upper 16bits of 32bit results
0244  0448             // Syntax: OVF();
0245  0449             // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
0246  0450             //       : hiWord := OVF();
0247  0451             // Notes : This function returns the high order 16 bits from certain math and shift functions..
0248  0452   
0249  0453             func SQRT("number"), 1;                         // return square root of a number
0250  0454             // Syntax: SQRT(number);
0251  0455             // Usage : SQRT(arg);
0252  0456             // Notes : Returns the integer square root of a number.
0253  0457             //------------------------------------------------------------------//
0254  0458             //          Text Related Function Prototypes
0255  0459             //------------------------------------------------------------------//
0256  0460   
0257  0461             func txt_MoveCursor("line", "column"), 0;
0258  0462             // Syntax: txt_SetCursor(line, column);
0259  0463             // Usage : txt_SetCursor(arg1, arg2);
0260  0464             // Notes : Moves the text Cursor to a new screen position set by
0261  0465             //       : line,column parameters.
0262  0466   
0263  0467             func txt_Set("mode", "value"), 0;
0264  0468             // Syntax: txt_Set(mode, value);
0265  0469             // Usage : txt_Set(arg1, arg2);
0266  0470             // Returns : Original value before the change
0267  0471             // Notes : Sets various text related parameters used by other functions
0268  0472             //       : This allows the features to be set programatically with a
0269  0473             //       : single function call.It is strongly recommended to use the
0270  0474             //       : pre-defined constants rather than the mode numbers.
0271  0475             //       : NB:- Although it is often required to be able to set text
0272  0476             //       : functions with a single function call for graphics engine
0273  0477             //       : related functions, there is a complete set of single parameter
0274  0478             //       : shortcut functions that have exactly the same function as
0275  0479             //       : each of the txt_Set modes and saves 1 parameter / uses less memory
0276  0480             //       :
0277  0481             //       : mode = TEXT_COLOUR (mode 0)
0278  0482             //       : txt_Set(TEXT_COLOUR, value);
0279  0483             //       : value = 0 to 0xFFFF, Black to White
0280  0484             //       : Sets the Text colour for the display
0281  0485             //       : Default = LIME.
0282  0486             //       :
0283  0487             //       : mode = TEXT_HIGHLIGHT (mode 1)
0284  0488             //       : txt_Set(TEXT_HIGHLIGHT, value);
0285  0489             //       : value = 0 to 0xFFFF, Black to White
0286  0490             //       : Sets the Text background colour for the display. Effective
0287  0491             //       : when text mode is Opaque.
0288  0492             //       : Default = BLACK.
0289  0493             //       :
0290  0494             //       : mode = FONT_ID (mode 2)
0291  0495             //       : txt_Set(FONT_ID, value);
0292  0496             //       : value = FONT1, FONT2 or FONT3 for internal fonts
0293  0497             //       : else this value is the name of a font included
0294  0498             //       : in a users program in a data statement.
0295  0499             //       : Default = FONT SIZE 3.
0296  0500             //       :
0297  0501             //       : mode = TEXT_WIDTH  (mode 3)
0298  0502             //       : txt_Set(TEXT_WIDTH, value);
0299  0503             //       : value = 1 to 16
0300  0504             //       : Sets the Text Width multiplier
0301  0505             //       : text will be printed magnified horizontally
0302  0506             //       : by this factor, Default = 1.
0303  0507             //       :
0304  0508             //       : mode = TEXT_HEIGHT  (mode 4)
0305  0509             //       : txt_Set(TEXT_HEIGHT, value);
0306  0510             //       : value = 1 to 16
0307  0511             //       : Sets the Text Height multiplier
0308  0512             //       : text will be printed magnified vertically
0309  0513             //       : by this factor, Default = 1.
0310  0514             //       :
0311  0515             //       : mode = TEXT_XGAP  (mode 5)
0312  0516             //       : txt_Set(TEXT_XGAP, value);
0313  0517             //       : value = 1 to 32
0314  0518             //       : Sets the horizontal gap between characters
0315  0519             //       : The gap is in pixel units, Default = 0
0316  0520             //       :
0317  0521             //       : mode = TEXT_YGAP  (mode 6)
0318  0522             //       : txt_Set(TEXT_YGAP, value);
0319  0523             //       : value = 1 to 32
0320  0524             //       : Sets the vertical gap below characters
0321  0525             //       : The gap is in pixel units, Default = 0
0322  0526             //       :
0323  0527             //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
0324  0528             //       : txt_Set(TEXT_PRINTDELAY, value);
0325  0529             //       : value = 0 to 255
0326  0530             //       : Sets the delay time (in ms) during character
0327  0531             //       : printing to give a 'teletype' like effect.
0328  0532             //       : Often used to attract attention to a string
0329  0533             //       : being printed which can often be missed if
0330  0534             //       : just suddenly appearing or changing.
0331  0535             //       : Default = 0 ms.
0332  0536             //       :
0333  0537             //       : mode = TEXT_OPACITY (mode 8)
0334  0538             //       : txt_Set(TEXT_OPACITY, value);
0335  0539             //       : value = TRANSPARENT (0) = Text Trasparent
0336  0540             //       : value = OPAQUE (1) = Text Opaque
0337  0541             //       : Sets the Opacity/Transparency of the text
0338  0542             //       : Default = 0 or TRANSPARENT
0339  0543             //       :
0340  0544             //       : mode = TEXT_BOLD (mode 9)
0341  0545             //       : txt_Set(TEXT_BOLD, value);
0342  0546             //       : value = dont care
0343  0547             //       : Sets Bold Text mode for the next string or char
0344  0548             //       : The feature automatically resets after printing
0345  0549             //       : using putstr or print has completed
0346  0550             //       :
0347  0551             //       : mode = TEXT_ITALIC (mode 10)
0348  0552             //       : txt_Set(TEXT_ITALIC, value);
0349  0553             //       : value = dont care
0350  0554             //       : Sets Italic Text mode for the next string or char
0351  0555             //       : The feature automatically resets after printing
0352  0556             //       : using putstr or print has completed
0353  0557   
0354  0558             //       : mode = TEXT_INVERSE (mode 11)
0355  0559             //       : txt_Set(TEXT_INVERSE, value);
0356  0560             //       : value = dont care
0357  0561             //       : Sets Inverse Text mode for the next string or char
0358  0562             //       : The feature automatically resets after printing
0359  0563             //       : using putstr or print has completed
0360  0564             //       :
0361  0565             //       : mode = TEXT_UNDERLINED (mode 12)
0362  0566             //       : txt_Set(TEXT_UNDERLINED, value);
0363  0567             //       : value = dont care
0364  0568             //       : Sets Underlined Text mode for the next string or char
0365  0569             //       : The feature automatically resets after printing
0366  0570             //       : using putstr or print has completed
0367  0571             //       :
0368  0572             //       : mode = TEXT_ATTRIBUTES (mode 13)
0369  0573             //       : txt_Set(TEXT_ATTRIBUTES, value);
0370  0574             //       : value = bits are defined as:
0371  0575             //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
0372  0576             //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
0373  0577             //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
0374  0578             //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
0375  0579             //       : Allows a combination of text attributes to be defined together
0376  0580             //       : by 'or'ing the bits together.
0377  0581             //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
0378  0582             //       : The feature automatically resets after printing
0379  0583             //       : using putstr or print has completed.
0380  0584             //       : Bits 0-3 and 8-15 are reserved for future attributes.
0381  0585             //       :
0382  0586             //       : mode = TEXT_WRAP (mode 14)
0383  0587             //       : txt_Set(TEXT_WRAP , value);
0384  0588             //       : Sets the position where text wrap will occur
0385  0589             //       : The feature automatically resets when screen
0386  0590             //       : mode is changed. If the value is set to 0,
0387  0591             //       : text wrap is turned off.
0388  0592             //       : of the current screen. Default value is 0
0389  0593             // Notes : The value is in pixel units.
0390  0594             //       :
0391  0595   
0392  0596             //       : txt_Set mode 15 reserved for future use
0393  0597             //       :
0394  0598   
0395  0599   
0396  0600   
0397  0601             //=====================================================//
0398  0602             // Single parameter short-cuts                         //
0399  0603             // for the txt_Set functions                           //
0400  0604             // These functions return the existing value before    //
0401  0605             // the change is made.                                 //
0402  0606             //=====================================================//
0403  0607             func txt_FGcolour("colour"), 1;             // 0  text foreground colour
0404  0608             func txt_BGcolour("colour"), 1;             // 1  text background colour
0405  0609             func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
0406  0610             func txt_Width("multiplier"), 1;            // 3  text width multiplier
0407  0611             func txt_Height("multiplier"), 1;           // 4  text height multiplier
0408  0612             func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
0409  0613             func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
0410  0614             func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
0411  0615             func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
0412  0616             func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
0413  0617             func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
0414  0618             func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
0415  0619             func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
0416  0620             func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
0417  0621             func txt_Wrap("value"), 1;                  // 14 text set text wrap position
0418  0622             func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
0419  0623   
0420  0624   
0421  0625             //------------------------------------------------------------------//
0422  0626             //                 Hardware Function Prototypes
0423  0627             //------------------------------------------------------------------//
0424  0628   
0425  0629             // I/O Pin reference:-
0426  0630             //
0427  0631             //    IO1_PIN           is pin 2 of J1
0428  0632             //    IO2_PIN           is pin 1 of J1
0429  0633             //    IO3_PIN           is pin 3 of J1
0430  0634             //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
0431  0635             //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
0432  0636             //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
0433  0637             //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
0434  0638             //    BUS_0             is pin 27 of J1
0435  0639             //    BUS_1             is pin 25 of J1
0436  0640             //    BUS_2             is pin 23 of J1
0437  0641             //    BUS_3             is pin 21 of J1
0438  0642             //    BUS_4             is pin 19 of J1
0439  0643             //    BUS_5             is pin 17 of J1
0440  0644             //    BUS_6             is pin 13 of J2
0441  0645             //    BUS_7             is pin 11 of J2
0442  0646             //    BACKLITE          is backlite control pin
0443  0647             //    AUDIO_ENABLE      is amplifier chip control pin
0444  0648   
0445  0649             func pin_Set("mode", "pin"), 1;            // set pin to required mode
0446  0650             // Syntax: pin_Set(mode, pin);
0447  0651             // Usage : pin_Set(arg1, arg2);
0448  0652             // Notes : Sets the appropriate pins to Inputs or Outputs
0449  0653             //       : returns true if the pin number is legal (usually ignored)
0450  0654             //       :
0451  0655             //       : mode = 0 : Set Pin to Output
0452  0656             //       : pin_Set(0, pin);
0453  0657             //       : pin_Set(OUTPUT, pin);
0454  0658             //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
0455  0659             //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
0456  0660             //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
0457  0661             //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
0458  0662             //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
0459  0663             //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
0460  0664             //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
0461  0665             //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
0462  0666             //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
0463  0667             //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
0464  0668             //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
0465  0669             //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
0466  0670             //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
0467  0671             //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
0468  0672             //       : Sets the desired pin to be used as an Output.
0469  0673             //       :
0470  0674             //       : mode = 1 : Set Pin to Input
0471  0675             //       : pin_Set(1, pin);
0472  0676             //       : pin_Set(INPUT, pin);
0473  0677             //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
0474  0678             //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
0475  0679             //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
0476  0680             //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
0477  0681             //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
0478  0682             //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
0479  0683             //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
0480  0684             //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
0481  0685             //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
0482  0686             //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
0483  0687             //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
0484  0688             //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
0485  0689             //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
0486  0690             //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
0487  0691             //       : Sets the desired pin to be used as an Input.
0488  0692   
0489  0693             func pin_HI("pin"), 1;                    // set pin to logic '1'
0490  0694             // Syntax: pin_HI(pin);
0491  0695             // Usage : pin_HI(arg);
0492  0696             // Notes : Outputs a logic "High" (3.3V) on the appropriate
0493  0697             //       : pin that was previously selected as an Output.
0494  0698             //       : returns true if the pin number is legal (usually ignored)
0495  0699             //       :
0496  0700             //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
0497  0701             //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
0498  0702             //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
0499  0703             //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
0500  0704             //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
0501  0705             //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
0502  0706             //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
0503  0707             //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
0504  0708             //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
0505  0709             //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
0506  0710             //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
0507  0711             //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
0508  0712             //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
0509  0713             //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
0510  0714             //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
0511  0715   
0512  0716             func pin_LO("pin"), 1;                    // set pin to logic '0'
0513  0717             // Syntax: pin_LO(pin);
0514  0718             // Usage : pin_LO(arg);
0515  0719             // Notes : Outputs a logic "Low" (0V) on the appropriate
0516  0720             //       : pin that was previously selected as an Output.
0517  0721             //       : returns true if the pin number is legal (usually ignored)
0518  0722             //       :
0519  0723             //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
0520  0724             //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
0521  0725             //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
0522  0726             //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
0523  0727             //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
0524  0728             //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
0525  0729             //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
0526  0730             //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
0527  0731             //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
0528  0732             //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
0529  0733             //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
0530  0734             //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
0531  0735             //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
0532  0736             //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
0533  0737             //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
0534  0738   
0535  0739             func pin_Read("pin"), 1;                // read pin, logic or analogue
0536  0740             // Syntax: pin_Read(pin);
0537  0741             // Usage : arg1 := pin_Read(arg2);
0538  0742             // Notes : Reads the logic state of the appropriate
0539  0743             //       : pin that was previously selected as an Input.
0540  0744             //       :
0541  0745             //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
0542  0746             //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
0543  0747             //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
0544  0748             //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
0545  0749             //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
0546  0750             //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
0547  0751             //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
0548  0752             //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
0549  0753             //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
0550  0754             //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
0551  0755             //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
0552  0756             //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
0553  0757             //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
0554  0758             //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
0555  0759             //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
0556  0760             //       : Returns a 0 (logic low) or 1 (logic high).
0557  0761   
0558  0762   
0559  0763             //------------------------------------------------------------------//
0560  0764             //                 P1 module BUS I/O control
0561  0765             //------------------------------------------------------------------//
0562  0766   
0563  0767             func bus_In(), 1;
0564  0768             // Syntax: bus_In();
0565  0769             // Usage : arg1 := bus_In();
0566  0770             // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
0567  0771             //       : The upper 8 bits of arg1 are set to 0.
0568  0772             //       : the BUS_RD and BUS_WR pins are not affected.
0569  0773             //       :
0570  0774             //       : BUS_0 is pin 27 of J1
0571  0775             //       : BUS_1 is pin 25 of J1
0572  0776             //       : BUS_2 is pin 23 of J1
0573  0777             //       : BUS_3 is pin 21 of J1
0574  0778             //       : BUS_4 is pin 19 of J1
0575  0779             //       : BUS_5 is pin 17 of J1
0576  0780             //       : BUS_6 is pin 13 of J2
0577  0781             //       : BUS_7 is pin 11 of J2
0578  0782   
0579  0783             func bus_Out("var"), 0;
0580  0784             // Syntax: bus_Out(var);
0581  0785             // Usage : bus_Out(arg1);
0582  0786             // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
0583  0787             //       : The upper 8 bits of arg1 are ignored.
0584  0788             //       : the BUS_RD and BUS_WR pins are not affected.
0585  0789             //       : NB:- any BUS pins that are set to inputs are not affected.
0586  0790             //       :
0587  0791             //       : BUS_0 is pin 27 of J1
0588  0792             //       : BUS_1 is pin 25 of J1
0589  0793             //       : BUS_2 is pin 23 of J1
0590  0794             //       : BUS_3 is pin 21 of J1
0591  0795             //       : BUS_4 is pin 19 of J1
0592  0796             //       : BUS_5 is pin 17 of J1
0593  0797             //       : BUS_6 is pin 13 of J2
0594  0798             //       : BUS_7 is pin 11 of J2
0595  0799   
0596  0800             func bus_Set("var"), 0;
0597  0801             // Syntax: bus_Set(var);
0598  0802             // Usage : bus_Set(arg1);
0599  0803             // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
0600  0804             //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
0601  0805             //       : The upper 8 bits of arg1 are ignored.
0602  0806             //       : the BUS_RD and BUS_WR pins are not affected.
0603  0807             //       :
0604  0808             //       : BUS_0 is pin 27 of J1
0605  0809             //       : BUS_1 is pin 25 of J1
0606  0810             //       : BUS_2 is pin 23 of J1
0607  0811             //       : BUS_3 is pin 21 of J1
0608  0812             //       : BUS_4 is pin 19 of J1
0609  0813             //       : BUS_5 is pin 17 of J1
0610  0814             //       : BUS_6 is pin 13 of J2
0611  0815             //       : BUS_7 is pin 11 of J2
0612  0816   
0613  0817             func bus_Write("var"), 0;
0614  0818             // Syntax: bus_Write(var);
0615  0819             // Usage : bus_Write(arg1);
0616  0820             // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
0617  0821             //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
0618  0822             //       : LO for approx 50nsec then set back HI.
0619  0823             //       : The upper 8 bits of arg1 are ignored.
0620  0824             //       : NB:- the BUS_WR pin is automatically pre-set to an output to
0621  0825             //       : ensure BUS write integrity.
0622  0826             //       :
0623  0827             //       : BUS_0 is pin 27 of J1
0624  0828             //       : BUS_1 is pin 25 of J1
0625  0829             //       : BUS_2 is pin 23 of J1
0626  0830             //       : BUS_3 is pin 21 of J1
0627  0831             //       : BUS_4 is pin 19 of J1
0628  0832             //       : BUS_5 is pin 17 of J1
0629  0833             //       : BUS_6 is pin 13 of J2
0630  0834             //       : BUS_7 is pin 11 of J2
0631  0835   
0632  0836             func bus_Read(), 1;
0633  0837             // Syntax: bus_Read();
0634  0838             // Usage : arg1 := bus_Read();
0635  0839             // Notes : The BUS_RD pin set to LO, then, after a settling delay
0636  0840             //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
0637  0841             //       : (the upper 8 bits being set to 0)
0638  0842             //       : the BUS_RD pin is then set back to a HI level.
0639  0843             //       : NB:- the BUS_RD pin is automatically pre-set to an output to
0640  0844             //       : ensure BUS write integrity.
0641  0845             //       :
0642  0846             //       : BUS_0 is pin 27 of J1
0643  0847             //       : BUS_1 is pin 25 of J1
0644  0848             //       : BUS_2 is pin 23 of J1
0645  0849             //       : BUS_3 is pin 21 of J1
0646  0850             //       : BUS_4 is pin 19 of J1
0647  0851             //       : BUS_5 is pin 17 of J1
0648  0852             //       : BUS_6 is pin 13 of J2
0649  0853             //       : BUS_7 is pin 11 of J2
0650  0854   
0651  0855   
0652  0856             //------------------------------------------------------------------//
0653  0857             //   Graphics Functions
0654  0858             //------------------------------------------------------------------//
0655  0859             func gfx_Set("mode", "value"), 0;            // set various graphics functions
0656  0860             // Syntax: gfx_Set(mode, value);
0657  0861             // Usage : gfx_Set(arg1, arg2);
0658  0862             // Notes : Sets various graphics parameters used by other functions
0659  0863             //       : This allows the features to be set programatically with a
0660  0864             //       : single function call.It is strongly recommended to use the
0661  0865             //       : pre-defined constants rather than the mode numbers.
0662  0866             //       : NB:- Although it is often required to be able to set graphics
0663  0867             //       : functions with a single function call for graphics engine
0664  0868             //       : related functions, there is a complete set of single parameter
0665  0869             //       : shortcut functions that have exactly the same function as
0666  0870             //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
0667  0871             //       :
0668  0872             //       : mode = PEN_SIZE (mode 16)
0669  0873             //       : gfx_Set(PEN_SIZE, value);
0670  0874             //       : value = SOLID (value 0) rectangle and circle objects are solid
0671  0875             //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
0672  0876             //       : Sets the mode of the Pen used by most graphics objects
0673  0877             //       :
0674  0878             //       : mode = BACKGROUND_COLOUR (mode 17)
0675  0879             //       : gfx_Set(BACKGROUND_COLOUR, value);
0676  0880             //       : value = 0 to 0xFFFF, Black to White
0677  0881             //       : Sets the Background colour of the screen
0678  0882             //       :
0679  0883             //       : mode = OBJECT_COLOUR (mode 18)
0680  0884             //       : gfx_Set(OBJECT_COLOUR, value);
0681  0885             //       : value = 0 to 0xFFFF, Black to White
0682  0886             //       : Sets the Object colour used in various functions
0683  0887             //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
0684  0888             //       :
0685  0889             //       : mode = CLIPPING (mode 19)
0686  0890             //       : gfx_Set(CLIPPING, value);
0687  0891             //       : value = OFF (value 0) Clipping disabled
0688  0892             //       : value = ON (value 1) Clipping enabled
0689  0893             //       : Enables/Disables the Clipping feature
0690  0894             //       :
0691  0895             //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
0692  0896             //       : gfx_Set(TRANSPARENT_COLOUR, value);
0693  0897             //       : value = 0 to 0xFFFF Black to White
0694  0898             //       : Sets Bitmap, Image or Animation Transparency Colour.
0695  0899             //       : NB not implemented
0696  0900             //       :
0697  0901             //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
0698  0902             //       : gfx_Set(5, value);
0699  0903             //       : value = OFF (value 0) Transparency disabled
0700  0904             //       : value = ON (value 1) Transparency enabled
0701  0905             //       : Enables/Disables the Transparency feature
0702  0906             //       : NB not implemented
0703  0907             //       :
0704  0908             //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
0705  0909             //       : gfx_Set(FRAME_DELAY, value);
0706  0910             //       : value = 0 to 65535 ms
0707  0911             //       : Sets the Video/Animation clip inter-frame delay. This setting will
0708  0912             //       : over-ride the embedded frame delay of the clip. After the event,
0709  0913             //       : the setting will auto disable and if further inter-frame delays need
0710  0914             //       : overriding the setting must be re-issued.
0711  0915             //       :
0712  0916             //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
0713  0917             //       : gfx_Set(SCREEN_MODE, value);
0714  0918             //       : value = LANDSCAPE   (value 0)
0715  0919             //       : value = LANDSCAPE_R (value 1)
0716  0920             //       : value = PORTRAIT    (value 2)
0717  0921             //       : value = PORTRAIT_R  (value 3)
0718  0922             //       :
0719  0923             //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
0720  0924             //       : gfx_Set(OUTLINE_COLOUR, value);
0721  0925             //       : value = 1 to 0xFFFF, if 0, featre is OFF
0722  0926             //       : Sets the filled Rectangle or Circle objects outline colour
0723  0927             //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
0724  0928             //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
0725  0929             //       :
0726  0930             //       : Only supports variable contrast for uOLED Modules
0727  0931             //       : mode = CONTRAST (mode 25) : Contrast
0728  0932             //       : gfx_Set(CONTRAST, value);
0729  0933             //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
0730  0934             //       : when contrast=0, display is placed in low power mode.
0731  0935             //       : This function should be called with contrast=0 when
0732  0936             //       : powering down the module.
0733  0937             //       :
0734  0938             //       : mode = LINE_PATTERN (mode 26) : Line Pattern
0735  0939             //       : gfx_Set(LINE_PATTERN, value);
0736  0940             //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
0737  0941             //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
0738  0942             //       : a value of 0 turns the feature off
0739  0943             //       :
0740  0944             //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
0741  0945             //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
0742  0946             //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
0743  0947             //       : NB not implemented, default is COLOUR16
0744  0948             //       :
0745  0949             //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
0746  0950             //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
0747  0951             //       : sets the button and slider objects bevel width
0748  0952             //       :
0749  0953             //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
0750  0954             //       : gfx_Set(BEVEL_SHADOW , 5);
0751  0955             //       : sets the button and slider objects darken and lighten depth for the bevel colour
0752  0956             //       :
0753  0957             //       : mode = X_ORIGIN (mode 29) : set x offset for screen
0754  0958             //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
0755  0959             //       : sets the origin of drawn objects to a position other than 0,0
0756  0960             //       :
0757  0961             //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
0758  0962             //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
0759  0963             //       : sets the origin of drawn objects to a position other than 0,0
0760  0964   
0761  0965   
0762  0966             func gfx_Cls(), 0;                    // clear the screen
0763  0967             // Syntax: gfx_Cls();
0764  0968             // Usage : gfx_Cls();
0765  0969             // Notes : Clears the screen with current background colour
0766  0970   
0767  0971             func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
0768  0972             // Syntax: gfx_MoveTo(x, y);
0769  0973             // Usage : gfx_MoveTo(arg1, arg2);
0770  0974             // Notes : Moves the origin to a new x,y position
0771  0975   
0772  0976             func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
0773  0977             // Syntax: gfx_MoveRel(x, y);
0774  0978             // Usage : gfx_MoveRel(arg1, arg2);
0775  0979             // Notes : Moves the origin to a new x,y position
0776  0980             //       : relative to the current origing
0777  0981   
0778  0982             func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
0779  0983             // Syntax: gfx_LineTo(x1, y1);
0780  0984             // Usage : gfx_LineTo(arg1, arg2);
0781  0985             // Notes : Draws a Line from the origin x,y to x1,y1.
0782  0986             //       : The new origin is then set to x1, y1. Line colour needs
0783  0987             //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0784  0988   
0785  0989             func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
0786  0990             // Syntax: gfx_LineRel(x1, y1);
0787  0991             // Usage : gfx_LineRel(arg1, arg2);
0788  0992             // Notes : Draws a Line from the origin x,y to x1,y1.
0789  0993             //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
0790  0994             //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
0791  0995   
0792  0996             func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
0793  0997             // Syntax: gfx_Line(x1, x2, y2, colr);
0794  0998             // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
0795  0999             // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
0796  1000   
0797  1001             func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
0798  1002             // Syntax: gfx_Line(x1, x2, y, colr);
0799  1003             // Usage : gfx_Line(arg1, arg2, arg3, arg4);
0800  1004             // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
0801  1005   
0802  1006             func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
0803  1007             // Syntax: gfx_Line(y1, y2, x, colr);
0804  1008             // Usage : gfx_Line(arg1, arg2, arg3, arg4);
0805  1009             // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
0806  1010   
0807  1011             func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
0808  1012             // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
0809  1013             // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0810  1014             // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
0811  1015             //       : bottom corner (x2,y2) on the screen.
0812  1016   
0813  1017             func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
0814  1018             // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
0815  1019             // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
0816  1020             // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
0817  1021             //       : bottom corner (x2,y2) on the screen.
0818  1022   
0819  1023             func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
0820  1024             // Syntax: gfx_Circle(x, y, rad, colr);
0821  1025             // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
0822  1026             // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
0823  1027   
0824  1028             func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
0825  1029             // Syntax: gfx_Circle(x, y, rad, colr);
0826  1030             // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
0827  1031             // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
0828  1032   
0829  1033             func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
0830  1034             // Syntax: gfx_PutPixel(x, y, colr);
0831  1035             // Usage : gfx_PutPixel(arg1, arg2, arg3);
0832  1036             // Notes : Plots a coloured pixel on the screen at x,y location
0833  1037   
0834  1038             func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
0835  1039             // Syntax: gfx_GetPixel(x, y);
0836  1040             // Usage : var := gfx_GetPixel(arg1, arg2);
0837  1041             // Notes : Reads and returns the colour value of a pixel at location x,y
0838  1042   
0839  1043             func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
0840  1044             // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
0841  1045             // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0842  1046             // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
0843  1047             //       : Vertices must be specified in an anti-clockwise fashion
0844  1048   
0845  1049             func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
0846  1050             // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
0847  1051             // Usage : gfx_OrbitInit(&arg1, &arg2);
0848  1052             // Notes : Sets up the Orbit function parameters.
0849  1053             //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
0850  1054             //       : variables that get updated after calling gfx_Orbit(,,) function.
0851  1055             //       : The coordiantaes are calculated relative to the origin
0852  1056             //       : obtained by using the gfx_MoveTo(x, y) function.
0853  1057   
0854  1058             func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
0855  1059             // Syntax: gfx_Orbit(angle, distance);
0856  1060             // Usage : gfx_Orbit(arg1, arg2);
0857  1061             // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
0858  1062             //       : only known parameters are the angle and the distance from the current origin.
0859  1063   
0860  1064             func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
0861  1065             // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
0862  1066             // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
0863  1067             // Notes : This function is very similar to the Ploygon function
0864  1068             //       : with the exception of the 1st and the last vertices not joined.
0865  1069   
0866  1070             func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
0867  1071             // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
0868  1072             // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
0869  1073             // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
0870  1074             //       : Vertices must be minimum of 3 and can be specified in any fashion
0871  1075   
0872  1076             func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
0873  1077             // Syntax: gfx_Dot();
0874  1078             // Usage : gfx_Dot();
0875  1079             // Notes : Places a coloured dot at the origin
0876  1080   
0877  1081   
0878  1082             func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
0879  1083             // Syntax: gfx_Bullet();
0880  1084             // Usage : gfx_Bullet();
0881  1085             // Notes : Places a coloured circle at the origin
0882  1086             //       : filled or unfilled state is controlled by PenSize
0883  1087   
0884  1088             func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
0885  1089             // Syntax: gfx_IncX();
0886  1090             // Usage : var := gfx_IncX();
0887  1091             // Notes : Increments the x coordinate of the origin
0888  1092   
0889  1093             func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
0890  1094             // Syntax: gfx_IncY();
0891  1095             // Usage : var := gfx_IncY();
0892  1096             // Notes : Increments the y coordinate of the origin
0893  1097   
0894  1098             func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
0895  1099             // Syntax: gfx_BoxTo(x1, y1);
0896  1100             // Usage : gfx_BoxTo(arg1, arg2);
0897  1101             // Notes : Draws a Rectangle from the origin x,y to x1,y1.
0898  1102             //       : The new origin is then set to x1,y1. Rectangle colour needs
0899  1103             //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
0900  1104             //       : and the PenSize setting determines if Box is solid or outline.
0901  1105   
0902  1106             func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
0903  1107             // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
0904  1108             // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
0905  1109             // Notes : Specifies a clipping window region on the screen such that any objects
0906  1110             //       : and text placed onto the screen will be clipped and displayed only
0907  1111             //       : within that region. For the clipping window to take effect, "Clipping"
0908  1112             //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
0909  1113   
0910  1114   
0911  1115             func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
0912  1116             // Syntax: gfx_ChangeColour(oldcolr, newcolr);
0913  1117             // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
0914  1118             // *Notes:
0915  1119   
0916  1120             func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
0917  1121             // Syntax: gfx_SetClipRegion();
0918  1122             // Usage : var := gfx_SetClipRegion();
0919  1123             // *Notes:
0920  1124   
0921  1125             func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
0922  1126             // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
0923  1127             // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
0924  1128             // Notes : Plots a coloured Ellipse on the screen at centre x,y
0925  1129             //       : with xradius = xrad and yradius = yrad.
0926  1130             //       : if PenSize = 0 Ellipse is Solid
0927  1131             //       : if PenSize = 1 Ellipse is Outline
0928  1132   
0929  1133   
0930  1134             func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
0931  1135             // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
0932  1136             // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
0933  1137             // Notes : Plots a coloured Ellipse on the screen at centre x,y
0934  1138             //       : with xradius = xrad and yradius = yrad.
0935  1139   
0936  1140             func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
0937  1141             // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
0938  1142             // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
0939  1143             // Notes : Draws a 3 dimensional Text Button at screen location defined by
0940  1144             //       : x,y arguments (top left corner). The size of the button depends on
0941  1145             //       : the font, width, height and length of the text.
0942  1146             //       : The button appearance will depend on the state parameter setting:
0943  1147             //       :         state = 0 : Button Pressed
0944  1148             //       :         state = 1 : Button Raised
0945  1149   
0946  1150             func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
0947  1151             // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
0948  1152             // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
0949  1153             // Notes : Draws a panel (groupbox) at screen location defined by
0950  1154             //       : x, y, width and height with colour "colour".
0951  1155             //       :         state = 0 : recessed
0952  1156             //       :         state = 1 : raised
0953  1157   
0954  1158             func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
0955  1159             // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
0956  1160             // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
0957  1161             // Notes : Draws a 3 dimensional Slider Bar on the screen.
0958  1162             //       : Slider parameters are as follows:
0959  1163             //       :         mode = 0 : Slider recessed
0960  1164             //       :         mode = 1 : Slider raised
0961  1165             //       :         x1, y1 = top left corner
0962  1166             //       :         x2, y2 = bottom right corner
0963  1167             //       :         scale = n : sets the full scale range from 0 to n
0964  1168             //       :         value = m : sets the relative position of the thumb 0 <= m <= n
0965  1169             //       : returns:-
0966  1170   
0967  1171   
0968  1172             func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
0969  1173             // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
0970  1174             // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
0971  1175             // Notes : Copies an area of a screen from xs,ys of size given by width and height
0972  1176             //       : and pastes it to another location determined by xd, yd.
0973  1177   
0974  1178             func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
0975  1179             // Syntax: gfx_RGBto565(red, green, blue);
0976  1180             // Usage : gfx_RGBto565(arg1, arg2, arg3);
0977  1181             // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
0978  1182   
0979  1183             func gfx_332to565("COLOUR8BIT"), 1;
0980  1184             // Syntax: gfx_332to565(colour);
0981  1185             // Usage : gfx_332to565(arg);
0982  1186             // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
0983  1187   
0984  1188             func gfx_Selection("index", "backcolor", "textcolor"), 0;
0985  1189             // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
0986  1190             // Usage : gfx_Selection(1, RED, YELLOW);
0987  1191             // Notes : Called prior to drawing a button, this function
0988  1192             //       : hilites the required text line on a multiline button.
0989  1193   
0990  1194             func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
0991  1195             // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
0992  1196             // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
0993  1197             // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
0994  1198             //       : Vertices must be specified in an anti-clockwise fashion
0995  1199   
0996  1200   
0997  1201             func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
0998  1202             // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
0999  1203             // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
1000  1204             // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
1001  1205             //       : Vertices must be minimum of 3 and can be specified in any fashion
1002  1206   
1003  1207   
1004  1208             func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
1005  1209             // Syntax: gfx_Offset(x, y);
1006  1210             // Usage : gfx_Offset(arg1, arg2);
1007  1211             // Notes : Set the screen offset
1008  1212   
1009  1213   
1010  1214   
1011  1215             func gfx_Get("mode"), 1;
1012  1216             // Syntax: gfx_Get(mode);
1013  1217             // Usage : arg1 := gfx_Get(arg);
1014  1218             // Notes : Returns various parameters to caller
1015  1219             //       :
1016  1220             //       : mode = X_MAX (mode 0) : current orientations maximum X value
1017  1221             //       : var := gfx_Get(X_MAX);
1018  1222             //       : Returns the maximum horizontal value of the display
1019  1223             //       :
1020  1224             //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
1021  1225             //       : var := gfx_Get(Y_MAX);
1022  1226             //       : Returns the maximum vertical value of the display
1023  1227             //       :
1024  1228             //       : mode = LEFT_POS (mode 2) : Left location of last Object
1025  1229             //       : var := gfx_Get(LEFT_POS);
1026  1230             //       : Returns the left location of the last drawn object
1027  1231             //       : such as a slider or button or an image/video
1028  1232             //       :
1029  1233             //       : mode = TOP_POS (mode 3) : Top location of Object
1030  1234             //       : var := gfx_Get(TOP_POS);
1031  1235             //       : Returns the top location of the last drawn object
1032  1236             //       : such as a slider or button or an image/video
1033  1237             //       :
1034  1238             //       : mode = RIGHT_POS (mode 4) : Right location of last Object
1035  1239             //       : var := gfx_Get(RIGHT_POS);
1036  1240             //       : Returns the right location of the last drawn object
1037  1241             //       : such as a slider or button or an image/video
1038  1242             //       :
1039  1243             //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
1040  1244             //       : var := gfx_Get(BOTTOM_POS );
1041  1245             //       : Returns the bottom location of the last drawn object
1042  1246             //       : such as a slider or button or an image/video
1043  1247             //       :
1044  1248   
1045  1249   
1046  1250             //==================================================//
1047  1251             // Single parameter short-cuts                      //
1048  1252             // for the gfx_Set functions                        //
1049  1253             // These functions return the existing value before //
1050  1254             // the change is made.                              //
1051  1255             //==================================================//
1052  1256             func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
1053  1257             func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
1054  1258             func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
1055  1259             func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
1056  1260             func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
1057  1261             func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
1058  1262             func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
1059  1263             func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
1060  1264             func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
1061  1265             func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
1062  1266             func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
1063  1267             func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
1064  1268             func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
1065  1269             func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
1066  1270             func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
1067  1271             func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
1068  1272   
1069  1273   
1070  1274             //==================================================//
1071  1275             // uSD/FLASH Function Prototypes                    //
1072  1276             //==================================================//
1073  1277             func media_Video("x", "y"), 0;                      // display movie at position x y
1074  1278             // Syntax: media_Video(x, y);
1075  1279             // Usage : media_Video(arg1, arg2);
1076  1280             // Notes : Play a Video/Animation clip from the uSD card at screen location
1077  1281             //       : specified by x,y (top left corner). The location of the clip in the
1078  1282             //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
1079  1283   
1080  1284             func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
1081  1285             // Syntax: media_VideoFrame(Frame_number);
1082  1286             // Usage : arg1 := media_VideoFrame();
1083  1287             // Notes : After a pointer to a valid video has been set with media_SetSector,
1084  1288             //       : calling this function shows each fram sequentially, returning
1085  1289             //       : the number of frames remaining. The position of the image is
1086  1290             //     : at the current origin as set with gfx_MoveTo(...);
1087  1291   
1088  1292             func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
1089  1293             // Syntax: media_SetAdd(AddHiWord, AddLoWord);
1090  1294             // Usage : media_SetAdd(arg1, arg2);
1091  1295             // Notes : Set uSD internal Address pointer for bytewise access
1092  1296   
1093  1297             func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
1094  1298             // Syntax: media_SetSector(SectHiWord, SectLoWord);
1095  1299             // Usage : media_SetSector(arg1, arg2);
1096  1300             // Notes : Set uSD internal Sector pointer for sector block access
1097  1301   
1098  1302             func media_RdSector("*destination"), 1;
1099  1303             // Syntax: media_RdSector(*destination);
1100  1304             // Usage : media_RdSector(rdblock);
1101  1305             // Notes : Reads and Returns 512 bytes (256 words) into a destination
1102  1306             //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
1103  1307             //       : After the read the Sector pointer is automatically incremented by 1.
1104  1308             //       : Returns TRUE if uSD response was TRUE
1105  1309   
1106  1310             func media_WrSector("*source"), 1;
1107  1311             // Syntax: media_WrSector(*source);
1108  1312             // Usage : media_WrSector(wrblock);
1109  1313             // Notes : Writes 512 bytes (256 words) from a source memory block
1110  1314             //       : (eg wrblock[256]) into the uSD card. After the write the Sector
1111  1315             //       : pointer is automatically incremented by 1.
1112  1316             //       : Returns TRUE if uSD response was TRUE
1113  1317   
1114  1318             func media_ReadByte(), 1;                // read a byte at the current stream position
1115  1319             // Syntax: media_RdByte();
1116  1320             // Usage : var := media_RdByte();
1117  1321             // Notes : Reads and Returns a single byte of data from the
1118  1322             //       : uSD card pointed to by the internal Address pointer.
1119  1323             //       : After the read the Address pointer is automatically
1120  1324             //       : incremented by 1.
1121  1325   
1122  1326             func media_ReadWord(), 1;                // read a word at the current stream position
1123  1327             // Syntax: media_ReadWord();
1124  1328             // Usage : var := media_ReadWord();
1125  1329             // *Notes : Reads and Returns a single word of data from the
1126  1330             //       : uSD card pointed to by the internal Address pointer.
1127  1331             //       : After the read the Address pointer is automatically
1128  1332             //       : incremented by 2.
1129  1333   
1130  1334             func media_WriteByte("byte"), 1;              // write a byte to the current stream position
1131  1335             // Syntax: media_WriteByte(arg1);
1132  1336             // Usage : var := media_WriteByte(arg1);
1133  1337             // *Notes : Writes and Returns xxxxx
1134  1338             //       : After the write the Address pointer is automatically
1135  1339             //       : incremented by 1.
1136  1340   
1137  1341             func media_WriteWord("word"), 1;            // write a word to the current stream position
1138  1342             // Syntax: media_WriteWord(arg1);
1139  1343             // Usage : var := media_WriteWord(arg1);
1140  1344             // *Notes : Writes and Returns xxxxx
1141  1345             //       : After the write the Address pointer is automatically
1142  1346             //       : incremented by 2.
1143  1347   
1144  1348             func media_Image("x", "y"), 0;            // display image at position x y
1145  1349             // Syntax: media_Image(x, y);
1146  1350             // Usage : media_Image(arg1, arg2);
1147  1351             // Notes : Display an image from the uSD card at screen location
1148  1352             //       : specified by x,y (top left corner). The location of the
1149  1353             //       : Image in the uSD card must be specified by
1150  1354             //       : media_setSector(Image_Sector_Add) function.
1151  1355   
1152  1356             func media_Flush(), 1;                    // after writing to media, flush the sector and write
1153  1357             // Syntax: media_Flush();
1154  1358             // Usage : var := media_Flush();
1155  1359             // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
1156  1360             //       : is being written is correctly stored back to the media else write operations may be unpredictable.
1157  1361   
1158  1362             func media_Init(), 1;                    // initialize uSD card
1159  1363             // Usage : media_Init();
1160  1364             // Notes : Initialise uSD CARD
1161  1365             //       : Response: 0 = No Card
1162  1366             //       :           1 = Card Initialised
1163  1367   
1164  1368   
1165  1369             //==============================================//
1166  1370             // Communications Function Prototypes           //
1167  1371             //==============================================//
1168  1372             func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
1169  1373             // Syntax: com_Init(buffer, bufsize, qualifier);
1170  1374             // Usage1: com_Init(mybuf, 20, 0);
1171  1375             // Usage2: com_Init(mybuf, 20, ':');
1172  1376             // Notes : initialize a serial capture buffer for the comms input
1173  1377             //       : The program must declare a var array as a circular buffer.
1174  1378             //       : Usage1 declares a circular buffer which will continually
1175  1379             //       : buffer characters.
1176  1380             //       : Usage2 must receive ':' before any characters will
1177  1381             //       : accumulate in the buffer.
1178  1382   
1179  1383             func com_Reset(), 0;                 // reset the comms receiver
1180  1384             // Syntax: com_Reset();
1181  1385             // Usage : com_Reset();
1182  1386             // Notes : reset comms to default polled mode
1183  1387   
1184  1388             func com_Count(), 1;                // return count of characters in receive buffer
1185  1389             // Syntax: com_Count();
1186  1390             // Usage : arg := com_Count();
1187  1391             // Notes : return count of buffered characters in buffer attachment
1188  1392   
1189  1393             func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
1190  1394             // Syntax: com_Full();
1191  1395             // Usage : if (com_Full() ,,,, go read buffer;
1192  1396             // Notes : return true if buffer full (not necessarily an error if
1193  1397             //       : buffer is sized to a packet size)
1194  1398   
1195  1399             func com_Error(), 1;                // return comms errors comms error occurred
1196  1400             // Syntax: com_Error();
1197  1401             // Usage : if (com_Error() ) ...... take recovery action;
1198  1402             // Notes : return non zero if any errors low level comms errors occured
1199  1403             // returns :
1200  1404             // bit0 = Receiver Overflow Error
1201  1405             // bit1 = Receiver Framing Error
1202  1406             // bit2 = Transmit Buffer Overflow
1203  1407   
1204  1408             func com_Sync(), 1;                // returns TRUE if qualifier has been received
1205  1409             // Syntax: com_Sync();
1206  1410             // Usage : com_Sync();
1207  1411             // return true if sync character has been received in com_Init("...") mode
1208  1412   
1209  1413   
1210  1414             func com_TXbuffer("buf", "bufsize"), 0;    // sets the buffer location for buffered transmission
1211  1415             // Syntax: com_TXbuffer("buf", "bufsize");
1212  1416             // Usage : com_TXbuffer(mybuf, 1024);       // set the TX buffer
1213  1417             // Usage : com_TXbuffer(0, 0);              // revert to non buffered service
1214  1418             // Notes : initialize a serial buffer for the COM0 output.
1215  1419             //       : The program must declare a var array as a circular buffer.
1216  1420             //       : When a TX buffer is declared for comms, the transmission
1217  1421             //       : of characters becomes non blocking. The only time
1218  1422             //       : blocking will occur is if the buffer has insufficient space
1219  1423             //       : to accet the next character, in which case the function
1220  1424             //       : will wait for buffer space to become available. If the
1221  1425             //       : TX buffer is no longer required, just set the buffer pointer
1222  1426             //       : to zero, the size in this case doesnt matter and is ignored.
1223  1427             //       : The function can resize or reallocated to another buffer at
1224  1428             //       : any time. The buffer is flushed before any changes are made.
1225  1429   
1226  1430             func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
1227  1431             // Syntax: com_TXcount();
1228  1432             // Usage : arg := com_Count();
1229  1433             // Notes : return count of characters remaining in COM0 transmit buffer
1230  1434             //       : that was previously allocated with com_TXbuffer(...);
1231  1435   
1232  1436             func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
1233  1437             // Syntax: com_TXemptyEvent(function);
1234  1438             // Usage : arg := com_TXemptyEvent();
1235  1439             // Notes : If a comms TX buffer that was previously allocated with
1236  1440             //       : com_TXbuffer(...);, this function can be used to set up
1237  1441             //       : a function to be called when the COM0 TX buffer is empty.
1238  1442             //       : This is useful for either reloading the TX buffer, setting
1239  1443             //       : or clearing a pin to change the direction of eg a RS485
1240  1444             //       : line driver, or any other form of traffic control.
1241  1445             //       : The event function must not have any parameters.
1242  1446             //       : To disable the event, simply call com_TXemptyEvent(0).
1243  1447             //       : com_TXbuffer(...); also resets any active event.
1244  1448             //       : com_TXemptyEvent returns any previous event function
1245  1449             //       : address, or zero if there was no previous function.
1246  1450   
1247  1451             func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
1248  1452             // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
1249  1453             // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
1250  1454             // Notes : Expecting that a comms TX buffer that was previously allocated with
1251  1455             //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
1252  1456             //       : the buffer being sent wile it is being loaded. Mormally, when
1253  1457             //       : using buffered comms, the transmit process will begin
1254  1458             //       : immediately. This is often undesirable for 2 reasons,
1255  1459             //       : 1] you may wish to build a packet then send it later
1256  1460             //       : 2] when using com_TXemptyEvent erroneous empty events will occur
1257  1461             //       : as the FIFO buffer is constantly trying to empty while
1258  1462             //       : you are busy tring to fill it.
1259  1463             // return -1 if function is called illegally when TX comms is not buffered.
1260  1464             // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
1261  1465             // return 0 when argument is zero, eg com_TXbufferHold(OFF)
1262  1466   
1263  1467   
1264  1468             //=============================================================//
1265  1469             // Auxilliary Communications Function Prototypes
1266  1470             //=============================================================//
1267  1471             func com1_Init("buffer", "bufsize", "qualifier"), 0;
1268  1472             // Syntax: com_Init(buffer, bufsize, qualifier);
1269  1473             // Usage1: com_Init(mybuf, 20, 0);
1270  1474             // Usage2: com_Init(mybuf, 20, ':');
1271  1475             // Notes : initialize a serial capture buffer for the comms input
1272  1476             //       : The program must declare a var array as a circular buffer.
1273  1477             //       : Usage1 declares a circular buffer which will continually
1274  1478             //       : buffer characters.
1275  1479             //       : Usage2 must receive ':' before any characters will
1276  1480             //       : accumulate in the buffer.
1277  1481   
1278  1482             func com1_Reset(), 0;
1279  1483             // Syntax: com_Reset();
1280  1484             // Usage : com_Reset();
1281  1485             // Notes : reset comms receiver to default polled mode
1282  1486   
1283  1487             func com1_Count(), 1;
1284  1488             // Syntax: com_Count();
1285  1489             // Usage : arg := com_Count();
1286  1490             // Notes : return count of characters in receive buffer
1287  1491   
1288  1492             func com1_Full(), 1;
1289  1493             // Syntax: com_Full();
1290  1494             // Usage : if (com_Full() ,,,, go read buffer;
1291  1495             // Notes : return true if receive buffer full
1292  1496   
1293  1497             func com1_Error(), 1;
1294  1498             // Syntax: com_Error();
1295  1499             // Usage : if (com_Error() ) ...... take recovery action;
1296  1500             // Notes : return non zero if any level comms errors occured
1297  1501             // returns :
1298  1502             // bit0 = Receiver Overflow Error
1299  1503             // bit1 = Receiver Framing Error
1300  1504             // bit2 = Transmit Buffer Overflow
1301  1505   
1302  1506             func com1_Sync(), 1;
1303  1507             // Syntax: com_Sync();
1304  1508             // Usage : com_Sync();
1305  1509             // Notes : return true if sync character has been received in com_Init("...") mode
1306  1510   
1307  1511   
1308  1512             func com1_TXbuffer("buf", "bufsize"), 0;    // sets the buffer location for buffered transmission
1309  1513             // Syntax: com1_TXbuffer("buf", "bufsize");
1310  1514             // Usage : com1_TXbuffer(mybuf, 1024);
1311  1515             // Usage : com1_TXbuffer(0, 0);              // revert to non buffered service
1312  1516             // Notes : initialize a serial buffer for the COM1 output.
1313  1517             //       : The program must declare a var array as a circular buffer.
1314  1518             //       : When a TX buffer is declared for comms, the transmission
1315  1519             //       : of characters becomes non blocking. The only time
1316  1520             //       : blocking will occur is if the buffer has insufficient space
1317  1521             //       : to accet the next character, in which case the function
1318  1522             //       : will wait for buffer space to become available. If the
1319  1523             //       : TX buffer is no longer required, just set the buffer pointer
1320  1524             //       : to zero, the size in this case doesnt matter and is ignored.
1321  1525             //       : The function can resize or reallocated to another buffer at
1322  1526             //       : any time. The buffer is flushed before any changes are made.
1323  1527   
1324  1528             func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
1325  1529             // Syntax: com1_TXcount();
1326  1530             // Usage : arg := com1_Count();
1327  1531             // Notes : return count of characters remaining in COM1 transmit buffer
1328  1532             //       : that was previously allocated with com1_TXbuffer(...);
1329  1533   
1330  1534             func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
1331  1535             // Syntax: com1_TXemptyEvent(function);
1332  1536             // Usage : arg := com1_TXemptyEvent();
1333  1537             // Notes : If a comms TX buffer that was previously allocated with
1334  1538             //       : com1_TXbuffer(...);, this function can be used to set up
1335  1539             //       : a function to be called when the COM1 TX buffer is empty.
1336  1540             //       : This is useful for either reloading the TX buffer, setting
1337  1541             //       : or clearing a pin to change the direction of eg a RS485
1338  1542             //       : line driver, or any other form of traffic control.
1339  1543             //       : The event function must not have any parameters.
1340  1544             //       : To disable the event, simply call com1_TXemptyEvent(0).
1341  1545             //       : com1_TXbuffer(...); also resets any active event.
1342  1546             //       : com1_TXemptyEvent returns any previous event function
1343  1547             //       : address, or zero if there was no previous function.
1344  1548   
1345  1549             func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
1346  1550             // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
1347  1551             // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
1348  1552             // Notes : Expecting that a comms TX buffer that was previously allocated with
1349  1553             //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
1350  1554             //       : the buffer being sent wile it is being loaded. Mormally, when
1351  1555             //       : using buffered comms, the transmit process will begin
1352  1556             //       : immediately. This is often undesirable for 2 reasons,
1353  1557             //       : 1] you may wish to build a packet then send it later
1354  1558             //       : 2] when using com_TXemptyEvent erroneous empty events will occur
1355  1559             //       : as the FIFO buffer is constantly trying to empty while
1356  1560             //       : you are busy tring to fill it.
1357  1561             // return -1 if function is called illegally when TX comms is not buffered.
1358  1562             // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
1359  1563             // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
1360  1564   
1361  1565             func serin1(), 1;
1362  1566             // Syntax: serin1();
1363  1567             // Usage : char := serin1();
1364  1568             // Notes : return the next available character from COM1
1365  1569   
1366  1570             func serout1("char"), 0;
1367  1571             // Syntax: serout1("char");
1368  1572             // Usage : serout1(ch);
1369  1573             // Notes : send character to COM1
1370  1574   
1371  1575             func com_SetBaud("comport","baudrate/10"), 1;
1372  1576             // Syntax: com_SetBaud("comport","baudrate/10");
1373  1577             // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
1374  1578             // Notes : sets to any viable baud rate from 160 to 655350
1375  1579             // return true if baud rate was acceptable
1376  1580   
1377  1581   
1378  1582   
1379  1583             //==============================================//
1380  1584             // Display Access                               //
1381  1585             //==============================================//
1382  1586             func disp_Init("INIT_table", "GRAM_code"), 0;   // initialize display with required tables
1383  1587                                                             // NB not available on current Picaso GFX2
1384  1588   
1385  1589             func disp_SetReg("register", "data"), 0;
1386  1590             // Syntax: display_SetReg(register, data);
1387  1591             // Usage : display_SetReg(arg1, arg2);
1388  1592             // Notes : Sets uLCD specific display driver registers. Refer
1389  1593             //       : to appropriate display driver data sheet.
1390  1594   
1391  1595             func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
1392  1596             // Syntax: disp_setGRAM(x1, y1, x2, y2);
1393  1597             // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
1394  1598             // Notes : Prepares the GRAM area for user access.
1395  1599             //       : Data can now be written with disp_GRAM.
1396  1600             //       : GRAM will be set accordingly for the correct screen mode.
1397  1601             //       : the LO word of the 32 bit pixel count is returned. This is
1398  1602             //       : usually all that is needed unlse GRAM area exceeds 256^2
1399  1603             //       : A copy of the 32bit value can be found in
1400  1604             //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
1401  1605   
1402  1606             func disp_WrGRAM("colour"), 0;
1403  1607             // Syntax: display_WrGRAM(colour);
1404  1608             // Usage : display_WrGRAM(arg);
1405  1609             // Notes : Data can be written to the GRAM consecutively using
1406  1610             //       : this function once the GRAM access window has been setup.
1407  1611   
1408  1612             func disp_WriteControl("value"), 0;             // write a control byte to the display
1409  1613             func disp_WriteWord("value"), 0;                // write a word to the display
1410  1614   
1411  1615   
1412  1616             func disp_ReadWord(), 1;                        // read a word from the display
1413  1617             // Syntax: disp_ReadWord();
1414  1618             // Usage : x:=disp_ReadWord();
1415  1619             // Notes : Read a word from the controller
1416  1620             // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
1417  1621             //       : print(disp_ReadWord());        // print ID
1418  1622             //       : (Many displays are write only)
1419  1623   
1420  1624                                                             //
1421  1625             //==============================================//
1422  1626             // unadorned SPI functions                      //
1423  1627             //==============================================//
1424  1628             func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
1425  1629             func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
1426  1630             func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
1427  1631             func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
1428  1632                                                             //
1429  1633             //==============================================//
1430  1634             // flash device specific functions              //
1431  1635             //==============================================//
1432  1636             func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
1433  1637             func flash_ID(), 1;                             // read ID code from FLASH device
1434  1638             func flash_BulkErase(), 0;                      // erase the entire FLASH device
1435  1639             func flash_BlockErase("block"), 1;              // erase the required 64k flash block
1436  1640                                                             //
1437  1641                                                             //
1438  1642             //==============================================//
1439  1643             // string and character size function           //
1440  1644             //==============================================//
1441  1645             func charwidth("char"), 1;                      // return width of a character in pixel units
1442  1646             func charheight("char"), 1;                     // return height of a character in pixel units
1443  1647             func strwidth("pointer"), 1;                    // return width of a string in pixel units
1444  1648             func strheight(), 1;                            // return height of a string in pixel units
1445  1649   
1446  1650   
1447  1651             //------------------------------------------------------------------//
1448  1652             //        I2C Function Prototypes
1449  1653             //------------------------------------------------------------------//
1450  1654             func I2C_Open("speed"), 0;
1451  1655             // Syntax: I2C_Open(speed),
1452  1656             // Usage : I2C_Open(I2C_MED);
1453  1657             // Notes : configures the I2C module
1454  1658             //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
1455  1659   
1456  1660             func I2C_Close(), 0;
1457  1661             // Syntax: I2C_Close();
1458  1662             // Usage : I2C_Close();
1459  1663             // Notes : disables the I2C1 module.
1460  1664   
1461  1665             func I2C_Start(), 1;
1462  1666             // Syntax: I2C_Start();
1463  1667             // Usage : I2C_Start();
1464  1668             // Notes : generates a Start condition.
1465  1669             //       : returns true if successful (usually ignored)
1466  1670   
1467  1671             func I2C_Stop(), 1;
1468  1672             // Syntax: I2C_Stop();
1469  1673             // Usage : I2C_Stop();
1470  1674             // Notes : generates a Stop condition.
1471  1675             //       : returns true if successful (usually ignored)
1472  1676   
1473  1677             func I2C_Restart(), 1;
1474  1678             // Syntax: I2C_Restart();
1475  1679             // Usage : I2C_Restart();
1476  1680             // Notes : generates a Restart condition.
1477  1681             //       : returns true if successful (usually ignored)
1478  1682   
1479  1683             func I2C_Read(), 1;
1480  1684             // Syntax: I2C_Read();
1481  1685             // Usage : ch := I2C_Read();
1482  1686             // Notes : reads a single byte from the I2C Bus.
1483  1687   
1484  1688             func I2C_Write("byte"), 1;
1485  1689             // Syntax: I2C_Write(byte);
1486  1690             // Usage : r := I2C_Write(ch);
1487  1691             // Notes : is used to write a byte to the I2C bus.
1488  1692             //       : Returns 0 if failed, 1 if no ack, 2 if ack
1489  1693   
1490  1694             func I2C_Ack(), 0;
1491  1695             // Syntax: I2C_Ack();
1492  1696             // Usage : I2C_Ack();
1493  1697             // Notes : generates the acknowledge condition.
1494  1698   
1495  1699             func I2C_Nack(), 0;
1496  1700             // Syntax: I2C_Nack();
1497  1701             // Usage : I2C_Nack();
1498  1702             // Notes : generates the negative acknowledge condition.
1499  1703   
1500  1704             func I2C_AckStatus(), 0;
1501  1705             // Syntax: I2C_AckStatus();
1502  1706             // Usage : r := I2C_AckStatus();
1503  1707             // Notes : returns the ACK status from the device.
1504  1708   
1505  1709             func I2C_AckPoll("control"), 1;
1506  1710             // Syntax: I2C_AckPoll();
1507  1711             // Usage : r := I2C_AckPoll(0xA0);
1508  1712             // Notes : waits for a device to return from ACK polling.
1509  1713   
1510  1714             func I2C_Idle(), 0;
1511  1715             // Syntax: I2C_Idle();
1512  1716             // Usage : I2C_Idle();
1513  1717             // Notes : waits until the I2C Bus is Inactive.
1514  1718   
1515  1719             func I2C_Gets("buffer", "size"), 1;
1516  1720             // Syntax: I2C_Gets("buffer", "size");
1517  1721             // Usage : r := I2C_Gets(mybuf, 16);
1518  1722             // Notes : only reads up to "size" characters into "buffer"
1519  1723             //       : Reads up to asciiz terminator including terminator
1520  1724   
1521  1725             func I2C_Getn("buffer", "size"), 1;
1522  1726             // Syntax: I2C_Gets("buffer", "size");
1523  1727             // Usage : r := I2C_Gets(mybuf, 16);
1524  1728             // Notes : reads "size" bytes into "buffer"
1525  1729             //       :
1526  1730   
1527  1731             func I2C_Puts("buffer"), 1;
1528  1732             // Syntax: I2C_Puts("buffer");
1529  1733             // Usage : r := I2C_Puts(mybuf);
1530  1734             // Notes : writes an asciiz string to the I2C device
1531  1735             //       : returns count of characters written
1532  1736   
1533  1737             func I2C_Putn("buffer", "count"), 1;
1534  1738             // Syntax: I2C_Putn("buffer","count");
1535  1739             // Usage : r := I2C_Puts(mybuf,10);
1536  1740             // Notes : writes up to "size" bytes to the I2C device
1537  1741             //       : returns number of bytes written
1538  1742   
1539  1743   
1540  1744             //------------------------------------------------------------------//
1541  1745             //        Image Control Function Prototypes
1542  1746             //------------------------------------------------------------------//
1543  1747             func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
1544  1748             // Syntax: img_SetPosition(handle, index, xpos, ypos);
1545  1749             // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
1546  1750             // Notes : set the position where the image will be displayed
1547  1751             //       : returns true if index was ok and function was successful.
1548  1752             //       : you may turn off an image so when img_Refresh is called,
1549  1753             //       : the image will not be shown
1550  1754   
1551  1755             func img_Enable("handle", "index"), 1;
1552  1756             // Syntax: img_Enable(handle, index);
1553  1757             // Usage : r := img_Enable(hImageList, imagenum);
1554  1758             // Notes : enable image in a image list
1555  1759             //       : returns true if index was ok and function was successful.
1556  1760             //       : this is the default state so when img_Refresh is called,
1557  1761             //       : all the images in the list will be shown
1558  1762             //       : if index is set to -1, all of the images are enabled
1559  1763   
1560  1764             func img_Disable("handle", "index"), 1;
1561  1765             // Syntax: img_Disable(handle, index);
1562  1766             // Usage : r := img_Disable(hImageList, imagenum);
1563  1767             // Notes : disable image in a image list
1564  1768             //       : returns true if index was ok and function was successful.
1565  1769             //       : you must turn off an image so when img_Refresh is called,
1566  1770             //       : the image will not be shown.
1567  1771             //       : if index is set to -1, all of the images are disabled
1568  1772   
1569  1773   
1570  1774             func img_Darken("handle", "index"), 1;
1571  1775             // Syntax: img_Darken(handle, index);
1572  1776             // Usage : r := img_Darken(hImageList, imagenum);
1573  1777             // Notes : darken image in a image list
1574  1778             //       : returns true if index was ok and function was successful.
1575  1779             //       : if index is set to -1, all of the images are darkened
1576  1780             //       : NB:- this feature will only work for the next refresh, then
1577  1781             //       : the image reverts back to normal when displayed again.
1578  1782   
1579  1783   
1580  1784             func img_Lighten("handle", "index"), 1;
1581  1785             // Syntax: img_Lighten(handle, index);
1582  1786             // Usage : r := img_Lighten(hImageList, imagenum);
1583  1787             // Notes : lighten image in a image list
1584  1788             //       : returns true if index was ok and function was successful.
1585  1789             //       : if index is set to -1, all of the images are lightened
1586  1790             //       : NB:- this feature will only work for the next refresh, then
1587  1791             //       : the image reverts back to normal when displayed again.
1588  1792   
1589  1793             func img_SetWord("handle", "index", "offset", "word"), 1;
1590  1794             // Syntax: img_SetWord(handle, index, offset, word);
1591  1795             // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
1592  1796             // Notes : set specified word (0-7) in a image entry
1593  1797             //       : returns TRUE if successful, return value usually ignored.
1594  1798   
1595  1799             func img_GetWord("handle", "index", "offset"), 1;
1596  1800             // Syntax: myvar := img_GetWord("handle", "index", "offset");
1597  1801             // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
1598  1802             // Notes : returns specified word (0-14) from an image entry
1599  1803             //       : refer to image control entry offsets.
1600  1804   
1601  1805             func img_Show("handle", "index"), 1;
1602  1806             // Syntax: img_Show(handle, index);
1603  1807             // Usage : display image entry (regardless of enable/disable)
1604  1808             //       : returns TRUE if successful, return value usually ignored.
1605  1809   
1606  1810             func img_SetAttributes("handle", "index","value"), 1;
1607  1811             // Syntax: img_SetAttributes("handle", "index","offset");
1608  1812             // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
1609  1813             // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
1610  1814             //       : of an image control entry. "value" refers to various bits in
1611  1815             //       : the image control entry (see image attribute flags).
1612  1816             //       : A '1' bit in the "value" field SETS the respective bit
1613  1817             //       : in the IMAGE_FLAGS field of the image control entry.
1614  1818             //       : returns TRUE if successful, return value usually ignored.
1615  1819   
1616  1820             func img_ClearAttributes("handle", "index","value"), 1;
1617  1821             // Syntax: img_ClearAttributes("handle", "index","offset");
1618  1822             // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
1619  1823             // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
1620  1824             //       : of an image control entry. "value" refers to various bits in
1621  1825             //       : the image control entry (see image attribute flags)
1622  1826             //       : a '1' bit in the "value" field CLEARS the respective bit
1623  1827             //       : in the IMAGE_FLAGS field of the image control entry.
1624  1828             //       : returns TRUE if successful, return value usually ignored.
1625  1829   
1626  1830             func img_Touched("handle", "index"), 1;
1627  1831             // Syntax: r := img_Touched(handle, index);
1628  1832             // Usage : img_Touched(hndl, 17);
1629  1833             //       : returns -1 if image not touched, or returns index
1630  1834             // Notes : if index is passed as -1, function tests all images,
1631  1835             //       : and returns -1 if image not touched, or returns index.
1632  1836   
1633  1837   
1634  1838   
1635  1839   
1636  1840             //------------------------------------------------------------------//
1637  1841             //        Timer Function Prototypes
1638  1842             //------------------------------------------------------------------//
1639  1843             func sys_T(), 1;
1640  1844             // Syntax: sys_T();
1641  1845             // Usage : t := sys_T();
1642  1846             // Notes : return the current value of the rolling system timer (1msec) LO word
1643  1847   
1644  1848             func sys_T_HI(), 1;
1645  1849             // Syntax: sys_T_HI();
1646  1850             // Usage : t := sys_T_HI();
1647  1851             // Notes : return the current value of the rolling system timer (1msec) HI word
1648  1852   
1649  1853             func sys_SetTimer("timernum","value"), 0;
1650  1854             // Syntax: sys_SetTimer("timernum", "value");
1651  1855             // Usage : sys_SetTimer(TIMER5, 10000);
1652  1856             // Notes : set a countdown on the selected timer, or 'top up' if required.
1653  1857             //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
1654  1858             //       : Maximum timeout period is 65.535 seconds
1655  1859             //       : A timer can be read with the sys_GetTimer("timernum") function
1656  1860   
1657  1861             func sys_GetTimer("timernum"), 1;
1658  1862             // Syntax: t := sys_GetTimer("timernum");
1659  1863             // Usage : t := sys_GetTimer(TIMER3);
1660  1864             // Notes : returns 0 if timer has expired, or the current countdown value.
1661  1865             //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
1662  1866             //       : Maximum timeout period is 65.535 seconds
1663  1867             //       : A timer must be set with the sys_SetTimer("timernum","value") function
1664  1868   
1665  1869             func sys_SetTimerEvent("timernum","function"), 1;
1666  1870             // Syntax: sys_SetTimerFunction("timernum", "function");
1667  1871             // Usage : sys_SetTimer(TIMER5, myfunc);
1668  1872             // Notes : set a function to be called for selected timer.
1669  1873             //       : When the timer reaches zero, the function is called.
1670  1874             //       : The called function must not have any parameters
1671  1875             //       : sys_SetTimerEvent returns any previous event function
1672  1876             //       : address, or zero if there was no previous function.
1673  1877   
1674  1878             func sys_EventQueue(), 1;
1675  1879             // Syntax: sys_EventQueue();
1676  1880             // Usage : tasks := sys_EventQueue();
1677  1881             // Notes : returns the max number of events that were pending
1678  1882             //       : in the timer queue since the last call to this function.
1679  1883             //       : This can be used to assess timer event overhead burden,
1680  1884             //       : especially after or during a sys_EventsPostpone action.
1681  1885   
1682  1886             func sys_EventsPostpone(), 0;
1683  1887             // Syntax: sys_EventPostpone();
1684  1888             // Usage : sys_EventPostpone();   // postpone the event queue
1685  1889             // Notes : postpone any events until the sys_EventResume function is executed
1686  1890             //       : The timer event queue will continue to queue events, but no action
1687  1891             //       : will take place untill a sys_EventResume function is encountered.
1688  1892             //       : The queue will continue to receive up to 32 events before discarding
1689  1893             //       : any further events. This function is required to allow a sequence of
1690  1894             //       : instructions or functions to occur that would otherwise be corrupted
1691  1895             //       : by an event occuring during the sequence of instructions or functions.
1692  1896             //       : A good example of this is when you set a position to print, if there
1693  1897             //       : was no way of locking the current sequence, an event may occur which
1694  1898             //       : does a similar thing, and a contention would occur - printing to
1695  1899             //       : the wrong position. This function should be used wisely, if any action
1696  1900             //       : that is required would take considerable time, it is better to disable
1697  1901             //       : any conflicting event functions with a bypass flag, then restart the
1698  1902             //       : conflicting event by re-issuing a timer value.
1699  1903   
1700  1904             func sys_EventsResume(), 0;
1701  1905             // Syntax: sys_EventsResume();
1702  1906             // Usage : sys_EventsResume();   // resume the event queue
1703  1907             // Notes : resume any postponed events. The queue will try to execute any timer
1704  1908             //       : events that were incurred during the postponed period.
1705  1909   
1706  1910   
1707  1911             func sys_Sleep("units"), 1;
1708  1912             // Syntax: t := sys_Sleep("units");
1709  1913             // Usage : t := sys_Sleep(10);
1710  1914             // Notes : sets the display into low power mode for a period of time.
1711  1915             //       : Touching the touch screen will also wake from sleep.
1712  1916             //       : Returns remaining sleep units.
1713  1917   
1714  1918             func iterator("offset"), 0;
1715  1919             // Syntax: t :=  iterator("offset");
1716  1920             // Usage : t :=  iterator(10);
1717  1921             // Notes : set the iterator size for ++/--
1718  1922             //       : The next postinc,postdec,preinc of predec will alter
1719  1923             //       : by the specified value.
1720  1924             //       : The offset will return to 1 after the next operation.
1721  1925   
1722  1926   
1723  1927   
1724  1928   
1725  1929             //------------------------------------------------------------------//
1726  1930             //         Touch Screen Function Prototypes
1727  1931             //------------------------------------------------------------------//
1728  1932   
1729  1933             func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
1730  1934             // Syntax: touch_DetectRegion(x1, y1, x2, y2);
1731  1935             // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
1732  1936             // Notes : Specifies a new touch detect region on the screen
1733  1937             //       : such that only touch activity in that region will
1734  1938             //       : be reported by the status poll touch_Get(TOUCH_STATUS);
1735  1939   
1736  1940             func touch_Set("mode"), 0;
1737  1941             // Syntax: touch_Set(mode);
1738  1942             // Usage : touch_Set(arg);
1739  1943             // Notes : Sets various Touch Screen related parameters
1740  1944             //       :
1741  1945             //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
1742  1946             //       : touch_Set(TOUCH_ENABLE);
1743  1947             //       : Enables and initialises Touch Screen hardware
1744  1948             //       :
1745  1949             //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
1746  1950             //       : touch_Set(TOUCH_DISABLE );
1747  1951             //       : Disables the Touch Screen
1748  1952             //       : Note: Touch Screen runs in the background and disabling
1749  1953             //       : it when not in use will free up extra resources
1750  1954             //       : such as 4DVM CPU cycles.
1751  1955             //       :
1752  1956             //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
1753  1957             //       : touch_Set(TOUCH_REGIONDEFAULT);
1754  1958             //       : This will reset the current active region to default
1755  1959             //       : to the full screen without the application having to
1756  1960             //       : set a new active region for the full screen.
1757  1961             //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
1758  1962             //       : that requre to be interfaced with an external pointing
1759  1963             //       : device, values that are poked into TOUCH_DRIVE will be
1760  1964             //       : read with the touch_Get() function)
1761  1965   
1762  1966   
1763  1967             func touch_Get("mode"), 1;
1764  1968             // Syntax: touch_Get(mode);
1765  1969             // Usage : arg1 := touch_Get(arg);
1766  1970             // Notes : Returns various Touch Screen parameters to caller
1767  1971             //       :
1768  1972             //       : mode = TOUCH_STATUS  (mode 0)
1769  1973             //       : var := touch_Get(TOUCH_STATUS);
1770  1974             //       : Returns the various states of the touch screen
1771  1975             //       : 0 = NOTOUCH
1772  1976             //       : 1 = TOUCH_PRESSED
1773  1977             //       : 2 = TOUCH_RELEASED
1774  1978             //       : 3 = TOUCH_MOVING
1775  1979             //       :
1776  1980             //       : mode = TOUCH_GETX   (mode 1)
1777  1981             //       : var := touch_Get(TOUCH_GETX);
1778  1982             //       : Returns the X coordinates of the touch
1779  1983             //       :
1780  1984             //       : mode = TOUCH_GETY   (mode 2)
1781  1985             //       : var := touch_Get(TOUCH_GETY);
1782  1986             //       : Returns the Y coordinates of the touch
1783  1987   
1784  1988             //------------------------------------------------------------------//
1785  1989             //        CTYPE Function Prototypes
1786  1990             //------------------------------------------------------------------//
1787  1991   
1788  1992             func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
1789  1993             // Syntax: isdigit("char");
1790  1994             // Usage : Var := isdigit(ch);
1791  1995             // Notes : char specifies the ascii character for the test
1792  1996             //     : 0 : char is not an ascii digit.
1793  1997             //     : 1 : char is an ascii digit..
1794  1998             //     : Valid range is "0123456789"
1795  1999   
1796  2000             func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
1797  2001             // Syntax: isxdigit("char");
1798  2002             // Usage : Var := isxdigit(ch);
1799  2003             // Notes : char specifies the ascii character for the test
1800  2004             //     : 0 : char is not an ascii hexadecimal digit.
1801  2005             //     : 1 : char is an ascii hexadecimal digit..
1802  2006             //     : Valid range is "0123456789ABCDEF"
1803  2007   
1804  2008             func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
1805  2009             // Syntax: isupper("char");
1806  2010             // Usage : Var := isupper(ch);
1807  2011             // Notes : char specifies the ascii character for the test
1808  2012             //     : 0 : char is not an ascii upper-case letter.
1809  2013             //     : 1 : char is an ascii upper-case letter.
1810  2014             //     : Valid range is "ABCD....WXYZ"
1811  2015   
1812  2016             func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
1813  2017             // Syntax: islower("char");
1814  2018             // Usage : Var := islower(ch);
1815  2019             // Notes : char specifies the ascii character for the test
1816  2020             //     : 0 : char is not an ascii lower-case letter.
1817  2021             //     : 1 : char is an ascii lower-case letter.
1818  2022             //     : Valid range is "abcd....wxyz"
1819  2023   
1820  2024             func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
1821  2025             // Syntax: isalpha("char");
1822  2026             // Usage : Var := isalpha(ch);
1823  2027             // Notes : char specifies the ascii character for the test
1824  2028             //     : 0 : char is not an ascii lower or upper case letter.
1825  2029             //     : 1 : char is an ascii lower or upper case letter.
1826  2030             //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
1827  2031   
1828  2032             func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
1829  2033             // Syntax: isalnum("char");
1830  2034             // Usage : Var := isalnum(ch);
1831  2035             // Notes : char specifies the ascii character for the test
1832  2036             //     : 0 : char is not an ascii alphanumeric character.
1833  2037             //     : 1 : char is an ascii alphanumeric character.
1834  2038             //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
1835  2039   
1836  2040             func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
1837  2041             // Syntax: isprint("char");
1838  2042             // Usage : Var := isprint(ch);
1839  2043             // Notes : char specifies the ascii character for the test
1840  2044             //     : 0 : char is not a printable ascii character.
1841  2045             //     : 1 : char is a printable ascii character.
1842  2046             //     : Valid range is "0x20...0x7F"
1843  2047   
1844  2048             func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
1845  2049             // Syntax: isspace("char");
1846  2050             // Usage : Var := isspace(ch);
1847  2051             // Notes : char specifies the ascii character for the test
1848  2052             //     : 0 : char is not a space type character.
1849  2053             //     : 1 : char is a space type character.
1850  2054             //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
1851  2055   
1852  2056             //unformatted
1853  2057             func iswhite("char"), 1;    //
1854  2058             // Syntax: iswhite("char");
1855  2059             // Usage : Var := iswhite(ch);
1856  2060             // Notes : char specifies the ascii character for the test
1857  2061             //     : 0 : char is not a space or tab character.
1858  2062             //     : 1 : char is not a space or tab character.
1859  2063             //     : Valid range is space or tab
1860  2064   
1861  2065             func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
1862  2066             // Syntax: toupper("char");
1863  2067             // Usage : Var := toupper(ch);
1864  2068             // Notes : char specifies the ascii character for the test
1865  2069             //     : "ABCD....XYZ" : if character is a lower case letter.
1866  2070             //     : char : if character is not a lower case letter.
1867  2071             //     : Valid range is "abcd....wxyz"
1868  2072   
1869  2073             func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
1870  2074             // Syntax: tolower("char");
1871  2075             // Usage : Var := tolower(ch);
1872  2076             // Notes : char specifies the ascii character for the test
1873  2077             //     : "abcd....xyz" : if character is an upper case letter.
1874  2078             //     : char : if character is not an upper case letter.
1875  2079             //     : Valid range is "ABCD....WXYZ"
1876  2080   
1877  2081             func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
1878  2082             // Syntax: LObyte(var);
1879  2083             // Usage : myVar := LObyte(myvar2);
1880  2084             // Notes : var specifies the user variable
1881  2085             //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
1882  2086   
1883  2087             func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
1884  2088             // Syntax: HIbyte(var);
1885  2089             // Usage : myVar := HIbyte(myvar2);
1886  2090             // Notes : var specifies the user variable
1887  2091             //     : Returns the high byte (upper 8 bits) of a 16 bit variable
1888  2092   
1889  2093   
1890  2094             func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
1891  2095             // Syntax: ByteSwap(var);
1892  2096             // Usage : myVar := ByteSwap(myvar2);
1893  2097             // Notes : var specifies the user variable
1894  2098             //     : Returns the endian swapped value of a 16 bit variable
1895  2099   
1896  2100   
1897  2101             //------------------------------------------------------------------//
1898  2102             //        Memory Allocation Function Prototypes
1899  2103             //------------------------------------------------------------------//
1900  2104   
1901  2105             func mem_Alloc("size"), 1;
1902  2106             // Syntax: mem_Alloc(bytesize);
1903  2107             // Usage : myvar := mem_Alloc(100);
1904  2108             // Notes : Allocate a block of memory to pointer myvar
1905  2109             //       : The allocated memory contains garbage but is a fast allocation.
1906  2110             //       : The block must later be released with mem_Free();
1907  2111             //       : returns 0 if function fails
1908  2112   
1909  2113             func mem_AllocV("size"), 1;
1910  2114             // Syntax: mem_AllocV(bytesize);
1911  2115             // Usage : myvar := mem_AllocV(100);
1912  2116             // Notes : Allocate a block of memory to pointer myvar
1913  2117             //       : The block of memory is filled with signature values
1914  2118             //       : the block starts with A5,5A then fills with incrementing
1915  2119             //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
1916  2120             //       : This can be helpful when debugging
1917  2121             //       : The block must later be released with mem_Free();
1918  2122             //       : returns 0 if function fails
1919  2123   
1920  2124             func mem_AllocZ("size"), 1;
1921  2125             // Syntax: mem_AllocZ(bytesize);
1922  2126             // Usage : myvar := mem_AllocC(100);
1923  2127             // Notes : Allocate a zeroed block of memory to pointer myvar
1924  2128             //       : The block of memory is filled with zeroes
1925  2129             //       : The block must later be released with mem_Free();
1926  2130             //       : returns 0 if function fails
1927  2131   
1928  2132             func mem_Realloc("ptr", "size"), 1;
1929  2133             // Syntax: myvar := mem_Realloc("ptr", "size");
1930  2134             // Usage : myvar := mem_Realloc(ptr, size);
1931  2135             // Notes : The function may move the memory block to a new location,
1932  2136             //       : in which case the new location is returned.
1933  2137             //       : The content of the memory block is preserved up to the lesser
1934  2138             //       : of the new and old sizes, even if the block is moved.
1935  2139             //       : If the new size is larger, the value of the newly allocated
1936  2140             //       : portion is indeterminate. In case that ptr is NULL,
1937  2141             //       : the function behaves exactly as mem_Alloc, assigning a new block
1938  2142             //       : of size bytes and returning a pointer to the beginning of it.
1939  2143             //       : In case that the size is 0, the memory previously allocated in
1940  2144             //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
1941  2145             //       : pointer is returned.
1942  2146   
1943  2147             func mem_Free("allocation"), 1;
1944  2148             // Syntax: myvar := mem_Free(allocation);
1945  2149             // Usage : myvar := mem_Free(myvar);
1946  2150             // Notes : De-allocate a block of memory previously created with
1947  2151             //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
1948  2152             //       : returns 0 if function fails
1949  2153   
1950  2154             func mem_Heap(), 1;
1951  2155             // Syntax: myvar := mem_Heap();
1952  2156             // Usage : myvar := mem_Heap();
1953  2157             // Notes : returns bytecount available in heap
1954  2158             //       :
1955  2159   
1956  2160             func mem_Set("ptr","char","size"), 1;
1957  2161             // Syntax: mem_Set(ptr,char,bytesize);
1958  2162             // Usage : mem_Set(p, 'A', 100);
1959  2163             // Notes : fill a block of memory with a byte value
1960  2164             //       : returns ptr
1961  2165   
1962  2166             func mem_Copy("src", "dest", "bytecount"), 1;
1963  2167             // Syntax: myvar := mem_Copy(src, dest, bytesize);
1964  2168             // Usage : myvar := mem_Copy(p1, p2, 100);
1965  2169             // Notes : copy a word aligned block of memory from src to dest
1966  2170             //       : Note that count is a byte count, this facilitates
1967  2171             //       : copying word aligned byte arrays when using word
1968  2172             //       : aliggned packed strings.
1969  2173             //       : returns src
1970  2174   
1971  2175             func mem_Compare("ptr1","ptr2","count"), 1;
1972  2176             // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
1973  2177             // Usage : myvar := mem_Compare(p1, p2, 100);
1974  2178             // Notes : compare blocks of memory at src, dest
1975  2179             //       : returns 0 if we have a match
1976  2180   
1977  2181             //------------------------------------------------------------------//
1978  2182             //        FAT16 Function Prototypes
1979  2183             //------------------------------------------------------------------//
1980  2184   
1981  2185             func file_Error(), 1;
1982  2186             // Syntax: myvar := file_Error();
1983  2187             // Usage : e := file_Error();
1984  2188             // Notes : return the most recent file error.
1985  2189             //       :
1986  2190   
1987  2191             func file_Count("filename"), 1;
1988  2192             // Syntax: count := file_Count("filename");
1989  2193             // Usage : count := file_Count("*.4dg");
1990  2194             // Notes : returns number of files found that match the criteria
1991  2195   
1992  2196             func file_Dir("filename"), 1;
1993  2197             // Syntax: count := file_Dir("filename");
1994  2198             // Usage : count := file_Dir("*.4dg");
1995  2199             // Notes : streams a string of filenames that agree with the search key
1996  2200             //       : returns number of files found that match the criteria
1997  2201   
1998  2202             func file_FindFirst("fname"), 1;
1999  2203             // Syntax: res := file_FindFirst("fname");
2000  2204             // Usage : if (file_FindFirst("*.4xe") ....
2001  2205             // Notes : returns true if at least 1 file exists
2002  2206             //       : that satisfies the file argument.
2003  2207             //       : Wildcards are usually used so if
2004  2208             //       : file_FindFirst returns true, further
2005  2209             //       : tests can be made using file_FindNext();
2006  2210             //       : to find all the files that match the
2007  2211             //       : wildcard class. Note that the stream behaviour
2008  2212             //       : is the same as file_Dir.
2009  2213             //       :
2010  2214   
2011  2215             func file_FindNext(), 1;
2012  2216             // Syntax: res := file_FindNext();
2013  2217             // Usage : while ((file_FindNext()) ....
2014  2218             // Notes : returns true if more file exists
2015  2219             //       : that satisfies the file argument
2016  2220             //       : that was given for  file_FindFirst.
2017  2221             //       : Wildcards must be used for
2018  2222             //       : file_FindFirst, else this function will
2019  2223             //       : always return zero as the only occurence
2020  2224             //       : will have already been found.
2021  2225             //       : Note that the stream behaviour
2022  2226             //       : is the same as file_Dir.
2023  2227             //       :
2024  2228   
2025  2229             func file_Exists("fname"), 1;
2026  2230             // Syntax: res := file_Exists("fname"),
2027  2231             // Usage : if(file_Exists("myfile") ....
2028  2232             // Notes : returns true if file exists
2029  2233             //       :
2030  2234   
2031  2235             func file_Open("fname", "mode"), 1;
2032  2236             // Syntax: handle := file_Open("fname","mode"),
2033  2237             // Usage : handle := file_Open("myfile.txt", 'r');
2034  2238             // Notes : returns handle if file exists
2035  2239             //       :
2036  2240   
2037  2241             func file_Close("handle"), 1;
2038  2242             // Syntax: res := file_Close("handle");
2039  2243             // Usage : res := file_Close(hnd1);
2040  2244             // Notes : returns true if file closed ok
2041  2245             //       :
2042  2246   
2043  2247             func file_Read("*dest", "size", "handle"), 1;
2044  2248             // Syntax: res := file_Read("*dest", "size", "handle"),
2045  2249             // Usage : res := file_Read(memblock,20,hnd1);
2046  2250             // Notes : returns number of characters read
2047  2251             //       : if "dest" is zero, data is read direct to GRAM window
2048  2252             //       :
2049  2253   
2050  2254   
2051  2255             func file_Seek("handle", "HiWord", "LoWord"), 1;
2052  2256             // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
2053  2257             // Usage : res := file_Seek(hSource, 0, 0x1234);
2054  2258             // Notes : set file position to 0x00001234 (byte position 4660)
2055  2259             //       : for the file handle so subsequent data may be read
2056  2260             //       : from that position onwards with file_GetC(...),
2057  2261             //       : file_GetW(...) or file_GetS(...), or an image
2058  2262             //       : can be displayed with file_Image(...)
2059  2263             // Notes : returns true if ok, usually ignored
2060  2264   
2061  2265             func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
2062  2266             // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
2063  2267             // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
2064  2268             // Notes : set file seek position to 123000
2065  2269             //       : for the file handle so subsequent data may be read
2066  2270             //       : from that record position onwards with file_GetC(...),
2067  2271             //       : file_GetW(...) or file_GetS(...), or an image
2068  2272             //       : can be displayed with file_Image(...)
2069  2273             // Notes : returns true if ok, usually ignored
2070  2274   
2071  2275             func file_Tell("handle", "&HiWord", "&LoWord"), 1;
2072  2276             // Syntax: file_Tell("handle", &HiWord, &LoWord);
2073  2277             // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
2074  2278             // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
2075  2279             //       : returns true if function succeeded
2076  2280   
2077  2281             func file_Write("*source", "size", "handle"), 1;
2078  2282             // Syntax: res := fwrite("*source", "size", "handle"),
2079  2283             // Usage : res := fwrite(memblock, 20, hnd1);
2080  2284             // Notes : returns number of bytes written
2081  2285             //       :
2082  2286   
2083  2287             func file_Size("handle", "&HiWord", "&LoWord"), 1;
2084  2288             // Syntax: file_Size("handle", &HiWord, &LoWord);
2085  2289             // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
2086  2290             // Notes : Reads the 32 bit file size and stores it into 2 variables.
2087  2291             //       : returns true if function succeeded
2088  2292   
2089  2293             func file_Image("x", "y", "handle"), 1;
2090  2294             // Syntax: file_Image(x, y, handle);
2091  2295             // Usage : file_Image(10, 10, hnd1);
2092  2296             // Notes : Display an image from a file at the current file position.
2093  2297             //       : The image is displayed at x,y (with respect to top left corner).
2094  2298             //       : If there is more than 1 image in the file, it can be
2095  2299             //       : accessed with file_Seek(...)
2096  2300   
2097  2301             func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
2098  2302             // Syntax: file_ScreenCapture(x, y, w, h, handle);
2099  2303             // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
2100  2304             // Notes : Save a image from screen to file at the current file position.
2101  2305             //       : The image can later be displayed with file_Image(...);
2102  2306             //       : The file may be opened in append mode to accumulate multiple
2103  2307             //       : images. Later, the images can be accessed with file_Seek(...);
2104  2308             //       : Note that the image will be sector aligned.
2105  2309             //       : All image headers must start on a sector boundary.
2106  2310             //       : The image is saved from x, y (with respect to top left corner)
2107  2311             //       : and the capture area is determined by "width" and "height".
2108  2312             //       : returns 0 if function succeeded
2109  2313   
2110  2314             func file_PutC("char","handle"), 1;
2111  2315             // Syntax: file_PutC("char", "handle");
2112  2316             // Usage : file_PutC('x', hndl);
2113  2317             // Notes : returns true if function succeeded
2114  2318   
2115  2319             func file_GetC("handle"), 1;
2116  2320             // Syntax: file_GetC("handle");
2117  2321             // Usage : mychar := fgetC("handle");
2118  2322             // Notes : returns next char from file
2119  2323   
2120  2324             func file_PutW("word","handle"), 1;
2121  2325             // Syntax: file_PutW("word","handle");
2122  2326             // Usage : file_PutW(0x1234, hndl);
2123  2327             // Notes : returns true if function succeeded
2124  2328   
2125  2329             func file_GetW("handle"), 1;
2126  2330             // Syntax: file_GetW("handle");
2127  2331             // Usage : myword := fgetW("handle");
2128  2332             // Notes : returns next word in file
2129  2333   
2130  2334             func file_PutS("*source", "handle"), 1;
2131  2335             // Syntax: res := file_Puts("*source", "handle"),
2132  2336             // Usage : res := file_Puts(mystring, hnd1);
2133  2337             // Notes : returns number of characters written
2134  2338             //       :
2135  2339   
2136  2340             func file_GetS("*string", "size", "handle"), 1;
2137  2341             // Syntax: res := file_Gets("*string", "size", "handle");
2138  2342             // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
2139  2343             // Notes : get a string from a file
2140  2344             //       : returns pointer to string or null if failed.
2141  2345             //       : file_GetS(...) automatically appends a null-terminator to the data read.
2142  2346             //       : NB:- only reads up to "size-1" characters into "string"
2143  2347             //       : file_GetS(...) will stop reading when any of the following conditions are true:
2144  2348             //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
2145  2349             //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
2146  2350             //       : C] It reaches the end of file
2147  2351             //       : D] A read error occurs.
2148  2352   
2149  2353   
2150  2354             func file_Erase("fname"), 1;
2151  2355             // Syntax: res := file_Erase("fname");
2152  2356             // Usage : res := file_Erase("myfile.txt");
2153  2357             // Notes : returns true if successful
2154  2358             //       :
2155  2359   
2156  2360             func file_Rewind("handle"), 1;
2157  2361             // Syntax: res := file_Rewind("handle");
2158  2362             // Usage : res := file_Rewind(hnd1);
2159  2363             // Notes : returns true if file rewound ok (usually ignored)
2160  2364             //       : resets the file pointer the the beginning of the open file.
2161  2365   
2162  2366             func file_LoadFunction("fname.4xe"), 1;
2163  2367             // Syntax: res := file_LoadFunction("fname.4fn");
2164  2368             // Usage : myfunc := file_LoadFunction(myfuncname);
2165  2369             // Notes : Load a function or program from disk and
2166  2370             //       : return a function pointer to the allocation.
2167  2371             //       : The function can then be invoked just like any other
2168  2372             //       : function would be called via a function pointer.
2169  2373             //       : Parameters may be passed to it in a conventional way.
2170  2374             //       : The function may be discarded at any time when no
2171  2375             //       : longer required, thus freeing its memory resources.
2172  2376             //       : The loaded function can be discarded with mem_Free(..)
2173  2377             //       : eg:
2174  2378             //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
2175  2379             //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
2176  2380             //       : then elsewhere in your program:-
2177  2381             //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
2178  2382             //       : if(res == QUIT_APPLICATION) goto exitApp;
2179  2383             //       : Later in your program, when popupWindow is no longer
2180  2384             //       : required for the application:-
2181  2385             //       : res := mem_Free(popupWindow);
2182  2386             //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
2183  2387             //       : The callers stack is shared by the loaded function,
2184  2388             //       : however any global variables in the loaded function
2185  2389             //       : are private to that function.
2186  2390             //
2187  2391   
2188  2392             func file_Run("fname.4xe", "arglistptr"), 1;
2189  2393             // Syntax: res := file_Run("fname.4xe","arglistptr");
2190  2394             // Usage : res := file_Run(fname, argptr);
2191  2395             // Notes : current program releases any allocated memory but
2192  2396             //       : retains the stack and global memory.
2193  2397             //       : If arglistptr is 0, no arguments are passed, else
2194  2398             //       : arglist points to an array, the first element being
2195  2399             //       : the number of elements in the array.
2196  2400             //       : func 'main' in the called program accepts
2197  2401             //       : the arguments, if any. THe arguments can only
2198  2402             //       : be passed by value, no pointers or references can be
2199  2403             //       : used as all memory is cleared before the file
2200  2404             //       : is loaded. Refer to file_Exec and file_LoadFunction
2201  2405             //       : for functions that can pass by reference.
2202  2406   
2203  2407             func file_Exec("fname.4xe", "arglistptr"), 1;
2204  2408             // Syntax: res := file_Exec("fname.4xe","arglistptr");
2205  2409             // Usage : res := file_Exec("fname.4xe","arglistptr");
2206  2410             // Notes : returns like a function, current program
2207  2411             //       : calling program is kept active and control returns to it.
2208  2412             //       : If arglistptr is 0, no arguments are passed, else
2209  2413             //       : arglist points to an array, the first element being
2210  2414             //       : the number of elements in the array.
2211  2415             //       : func 'main' in the called program accepts the arguments.
2212  2416             //       : This function is similar to file_LoadFunction(...), however,
2213  2417             //       : the function argument list is passed by pointer, and
2214  2418             //       : the memory consumed by the function is released as
2215  2419             //       : soon as the function completes.
2216  2420   
2217  2421             func file_LoadImageControl("fname1", "fname2", "mode"), 1;
2218  2422             // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
2219  2423             // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
2220  2424             // Notes : Reads a control file to create an image list.
2221  2425             //       : Returns NULL if function fails.
2222  2426             //       : Returns a handle (pointer to the memory allocation) to the
2223  2427             //       : image control list that has been created.
2224  2428             //       : "fname1" is the control list filename "*.dat"
2225  2429             //       : "fname2" is the image filename "*.gci"
2226  2430   
2227  2431             // Notes : This function Calculates the size of a chunk of memory required for
2228  2432             //       : a image list and populates it from the image control file ("*.dat")
2229  2433             //       : therefore, when imagelist is no longer required, you must de-allocate
2230  2434             //       : the image list memory by using eg:- mem_Free(hImagelist);
2231  2435             //       : to restore the heap.
2232  2436             //       :
2233  2437             //       : mode 0:- it is assumed that there is a graphics file with the
2234  2438             //       : file extension "fname2.gci". In this case, the images have been stored
2235  2439             //       : in a FAT16 file concurrently, and the offsets that ar derived from the
2236  2440             //       : "fname1.dat" file are saved in the image control so that the image control
2237  2441             //       : can open the file (*.gci) and us file_Seek to get to the position of the
2238  2442             //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
2239  2443             //       : mode 0 builds the image control quickly as it only scans the *.dat file
2240  2444             //       : for the file offsets and save them in the relevant entries in the image control.
2241  2445             //       : The penalty is that images take longer to find when displayed due to file_Seek
2242  2446             //       : overheads.
2243  2447             //
2244  2448             //       : mode 1:- it is assumed that there is a graphics file with the
2245  2449             //       : file extension "fname2.gci". In this case, the images have been stored
2246  2450             //       : in a FAT16 file concurrently, and the offset of the images are saved
2247  2451             //       : in the image control so that image file (*.gci) can be mapped to directly.
2248  2452             //       : The absolute cluster/sector is mapped so file seek does not need to be called
2249  2453             //       : internally. This means that there is no seek time penalty, however, the
2250  2454             //       : image list takes a lot longer to build, as all the seeking is done at control
2251  2455             //       : build time.
2252  2456   
2253  2457             //       : mode 2:- the graphics file with the is placed in a partitioned area
2254  2458             //       : In this case, the images have been stored in a in a known raw area of the FAT16
2255  2459             //       : disk, and the absolute address of the images are saved in the DAT file
2256  2460             //       : This is the fastest operation of the image control as there is no seeking
2257  2461             //       : or other disk activity taking place.
2258  2462   
2259  2463             func file_Mount(), 1;
2260  2464             // Syntax: r := file_Mount();
2261  2465             // Usage : r := file_Mount();
2262  2466             // Notes : Create a control block for FAT16 and mount the File System
2263  2467   
2264  2468             func file_Unmount(), 0;
2265  2469             // Syntax: file_Unmount();
2266  2470             // Usage : file_Unmount();
2267  2471             // Notes : release any control block and buffers for FAT16
2268  2472             //       : and unmount the File System
2269  2473   
2270  2474             func file_PlayWAV("fname1"), 1;
2271  2475             // Syntax: file_PlayWAV("fname1");
2272  2476             // Usage : file_PlayWAV("ding.wav");
2273  2477             // Notes : Play a wave file with filename "fname1"
2274  2478             //       : This function automatically grabs a chunk
2275  2479             //       : of memory for a file buffer, and a wave
2276  2480             //       : buffer. The minimum memory requirement is
2277  2481             //       : about 580 bytes for the disk io service and
2278  2482             //       : a minimum wave buffer size of 1024. The siz
2279  2483             //       : of the wave buffer allocation
2280  2484             //       : can be increased by the snd_BufSize function.
2281  2485             //       : The default size 1024 bytes.
2282  2486             //       : NB the memory is only required during the
2283  2487             //       : duration of play, and is automatically
2284  2488             //       : released while not in use.
2285  2489             //       : See the Sound Class services for other associated controls.
2286  2490             //       : If there are no errors, returns number of blocks to play (1 to 32767)
2287  2491             //       : If errors occured, the folling is returned
2288  2492             //       : -6   : cant play this rate
2289  2493             //       : -5  : no data chunk found in first rsector
2290  2494             //       : -4  : no format data
2291  2495             //       : -3  : no wave chunk signature
2292  2496             //       : -2  : bad wave file format
2293  2497             //       : -1  : file not found
2294  2498   
2295  2499   
2296  2500   
2297  2501             //------------------------------------------------------------------//
2298  2502             //        Sound Class Services
2299  2503             //------------------------------------------------------------------//
2300  2504   
2301  2505             func snd_Volume("var"), 0;
2302  2506             // Syntax: snd_Volume("var");
2303  2507             // Usage : snd_Volume(30);
2304  2508             // Notes : set sound playback volume.  Var must
2305  2509             //       : be in the range from 8 (min volume)
2306  2510             //       : to 127 (max volume). If var is less
2307  2511             //       : than 8 volume is set to 8, and if
2308  2512             //       : var > 127 it is set to 127.
2309  2513   
2310  2514             func snd_Pitch("pitch"), 1;
2311  2515             // func snd_Pitch("freq"), 1;
2312  2516             // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
2313  2517             // Notes : sets the samples playback rate to a different frequency
2314  2518             //       : The minimum value is 4khz
2315  2519             //       : Setting the pitch to zero restores the original sample rate
2316  2520             //       : Return value is the samples original sample rate.
2317  2521   
2318  2522             func snd_BufSize("var"), 0;
2319  2523             // Syntax: snd_BufSize("var");
2320  2524             // Usage : snd_BufSize(2);
2321  2525             // Notes : specify the a memory chunk size for the wavefile buffer.
2322  2526             //       : default size 1024 bytes.
2323  2527             //       : 0 = 1024 bytes (default)
2324  2528             //       : 1 = 2048 bytes
2325  2529             //       : 2 = 4096 bytes
2326  2530             //       : 3 = 8192 bytes
2327  2531   
2328  2532             func snd_Stop(), 0;
2329  2533             // Syntax: snd_Stop();
2330  2534             // Usage : snd_Stop();
2331  2535             // Notes : stop any sound that is playing, releasing
2332  2536             //       : buffers and closes any open wav file.
2333  2537   
2334  2538             func snd_Pause(), 0;
2335  2539             // Syntax: snd_Pause();
2336  2540             // Usage : snd_Pause();
2337  2541             // Notes : pauses any sound that is playing, does nothing
2338  2542             //       : until sound is resumed with snd_Continue().
2339  2543             //       : The sample cam be terminated with snd_Stop.
2340  2544             //       : buffers and closes any open wav file.
2341  2545   
2342  2546             func snd_Continue(), 0;
2343  2547             // Syntax: snd_Continue();
2344  2548             // Usage : snd_Continue();
2345  2549             // Notes : resume any sound that is paused by snd_Pause.
2346  2550   
2347  2551             func snd_Playing(), 1;
2348  2552             // Syntax: snd_Playing();
2349  2553             // Usage : r := snd_Playing();
2350  2554             // Notes : returns 0 if sound has finished playing,
2351  2555             //       : else return number of 512 byte blocks to go.
2352  2556   
2353  2557   
2354  2558   
2355  2559             //------------------------------------------------------------------//
2356  2560             //        String Class Services
2357  2561             //------------------------------------------------------------------//
2358  2562   
2359  2563             func str_Ptr("&var"), 1;
2360  2564             // Syntax: str_Ptr(&var);
2361  2565             // Usage : p := str_Ptr(&var);
2362  2566             // Notes : return a byte pointer to a word region
2363  2567   
2364  2568             func str_GetD("&ptr", "&var"), 1;
2365  2569             // Syntax: str_GetD(&ptr, &var);
2366  2570             // Usage : ok := str_GetD(&ptr, &var);
2367  2571             // Notes : convert number in a string to DWORD ( myvar[2] )
2368  2572             //       : returns true if function succeeds, advancing ptr
2369  2573   
2370  2574             func str_GetW("&ptr", "&var"), 1;
2371  2575             // Syntax: str_GetW(&ptr, &var);
2372  2576             // Usage : ok := str_GetW(&ptr, &var);
2373  2577             // Notes : convert number in a string to WORD ( myvar )
2374  2578             //       : returns true if function succeeds, advancing ptr
2375  2579   
2376  2580             func str_GetHexW("&ptr", "&var"), 1;
2377  2581             // Syntax: str_GetHexW(&ptr, &var);
2378  2582             // Usage : ok := str_GetHexW(&ptr, &var);
2379  2583             // Notes : convert HEX number in a string to WORD ( myvar )
2380  2584             //       : returns true if function succeeds, advancing ptr
2381  2585   
2382  2586             func str_GetC("&ptr", "&var"), 1;
2383  2587             // Syntax: str_GetC(&ptr, &var);
2384  2588             // Usage : ok := str_GetC(&ptr, &var);
2385  2589             // Notes : get a valid ascii char in a string to WORD ( myvar )
2386  2590             //       : returns true if function succeeds, advancing ptr
2387  2591   
2388  2592             func str_GetByte("ptr"), 1;
2389  2593             // Syntax: str_GetByte(ptr);
2390  2594             // Usage : myvar := str_GetByte(ptr);
2391  2595             // Notes : get a byte to myvar
2392  2596             //       : returns value
2393  2597   
2394  2598             func str_GetWord("ptr"), 1;
2395  2599             // Syntax: GetWord(ptr);
2396  2600             // Usage : GetWord(ptr);
2397  2601             // Notes : get a word to myvar
2398  2602             //       : returns value
2399  2603   
2400  2604             func str_PutByte("ptr","val"), 0;
2401  2605             // Syntax: str_PutByte(ptr);
2402  2606             // Usage : myvar := str_PutByte(ptr);
2403  2607             // Notes : put a byte at ptr
2404  2608             //       : returns value
2405  2609   
2406  2610             func str_PutWord("ptr","val"), 0;
2407  2611             // Syntax: str_PutWord("ptr","val");
2408  2612             // Usage : str_PutWord(p,100);
2409  2613             // Notes : put word 100 at current pointer location
2410  2614             //       : returns value
2411  2615   
2412  2616             func str_Match("&ptr", "*str"), 1;
2413  2617             // Syntax: str_Match(&ptr, *str);
2414  2618             // Usage : r := str_Match(&p, "hello");
2415  2619             // Notes : Case sensitive match
2416  2620             //       : returns true if function succeded, andvancing pointer to position past
2417  2621             //       : the matched item. Note that any whitespace characters are skipped
2418  2622             //       : in the source string prior to the test.
2419  2623   
2420  2624             func str_MatchI("&ptr", "*str"), 1;
2421  2625             // Syntax: str_MatchI(&ptr, *str);
2422  2626             // Usage : r := str_MatchI(&p, "hello");
2423  2627             // Notes : Case insensitive match
2424  2628             //       : returns true if function succeded, andvancing pointer to position past
2425  2629             //       : the matched item. Note that any whitespace characters are skipped
2426  2630             //       : in the source string prior to the test.
2427  2631   
2428  2632             func str_Find("&ptr", "*str"), 1;
2429  2633             // Syntax: str_Find(&ptr, *str);
2430  2634             // Usage : n := str_Find(&p, "hello");
2431  2635             // Notes : given the address of a pointer to a source string as the
2432  2636             //       : first argument, and a pointer to a test string as the second
2433  2637             //       : argument, attempt to find the position of the matching string
2434  2638             //       : in the source string. The test is performed with case sensitivity.
2435  2639             //       : return 0 if not found, else returns the address of the first
2436  2640             //       : character of the match. NB:- The source pointer is not altered.
2437  2641   
2438  2642             func str_FindI("&ptr", "*str"), 1;
2439  2643             // Syntax: str_Find(&ptr, *str);
2440  2644             // Usage : n := str_Find(&p, "hello");
2441  2645             // Notes : given the address of a pointer to a source string as the
2442  2646             //       : first argument, and a pointer to a test string as the second
2443  2647             //       : argument, attempt to find the position of the matching string
2444  2648             //       : in the source string. The test is performed with no case
2445  2649             //       : sensitivity, eg upper and lower case chars are accepted.
2446  2650             //       : return 0 if not found, else returns the address of the first
2447  2651             //       : character of the match. NB:- The source pointer is not altered.
2448  2652   
2449  2653             func str_Length("ptr"), 1;
2450  2654             // Syntax: str_Length(ptr);
2451  2655             // Usage : len := str_Ptr(mystring);
2452  2656             // Notes : return the length of a byte aligned string excluding terminator
2453  2657   
2454  2658             func str_Printf("&ptr", "*format"), 1;
2455  2659             // Syntax: str_Printf("&ptr", "*format");
2456  2660             // Usage : r := str_Printf(&p, "hello");
2457  2661             // Notes : refer to documentation
2458  2662             //       :
2459  2663   
2460  2664             func str_Cat("dest","src"), 1;
2461  2665             // Syntax: str_Append("&dest","&src");
2462  2666             // Usage : str_Append(&buf,"Hello");
2463  2667             // Notes : Appends a copy of the source string to the destination string.
2464  2668             //       : The terminating null character in destination is overwritten by
2465  2669             //       : the first character of source, and a new null-character is appended
2466  2670             //       : at the end of the new string formed by the concatenation of both in destination.
2467  2671             //       : returns destination.
2468  2672   
2469  2673             func str_CatN("dest","src","count"), 1;
2470  2674             // Syntax: str_Append("&dest","&src","count");
2471  2675             // Usage : str_Append(&buf,"Monday",3);
2472  2676             // Notes : Appends a copy of the source string to the destination string.
2473  2677             //       : The number of characters copied is limited by "count".
2474  2678             //       : The terminating null character in destination is overwritten by
2475  2679             //       : the first character of source, and a new null-character is appended
2476  2680             //       : at the end of the new string formed by the concatenation of both in destination.
2477  2681             //       : returns destination.
2478  2682   
2479  2683   
2480  2684             func sys_StoreTouchCalibration(), 1;
2481  2685             // Syntax: sys_StoreTouchCalibration();
2482  2686             // Usage : r := sys_StoreTouchCalibration();
2483  2687             // Notes : Store the touch calibration values in non-volatile memory.
2484  2688             //       : Returns true if the values have been accepted and stored,
2485  2689             //       : else returns false if write could not be performed, or
2486  2690             //       : touch calibration values are improbable.
2487  2691             //       : The values that are stored are obtained from:-
2488  2692             //     : TOUCH_XMINCAL             78  // touch calibration value
2489  2693             //     : TOUCH_YMINCAL             79  // touch calibration value
2490  2694             //       : TOUCH_XMAXCAL             80  // touch calibration value
2491  2695             //       : TOUCH_YMAXCAL             81  // touch calibration value
2492  2696             //       : refer to the 4DGL example touchCalibrate.4DG for further information.
2493  2697             //       : This function is not supported on uVGA, Capicitive touch
2494  2698             //       : and 4.3" resistive touch modules.
2495  2699   
2496  2700   
2497  2701             func unicode_page("charbeg","charend","charoffset"), 1;
2498  2702             // Syntax: unicode_page("charbeg","charend","charoffset");
2499  2703             // Usage : eg:  F_Traditional_0x20_0xFF
2500  2704             // Notes : After selecting a unicode image control with txt_FontID,
2501  2705             //       : this function is called to set the required font within the
2502  2706             //       : unicode set. The file "Unicode.inc" contains wrappers for
2503  2707             //       : this function, and it is not normally called directly.
2504  2708             //       : Returns count of characters in the set.
2505  2709             //       : Refer to "Unicode.inc" for further information.
2506  2710   
2507  2711   
2508  2712             func EVE_SP(), 1;
2509  2713             // Syntax: EVE_SP();
2510  2714             // Usage : eg:  print(EVE_SP());
2511  2715             // Notes : Used for debugging to assess the current stack level,
2512  2716             //       : mainly for checking stack leaks
2513  2717   
2514  2718             func EVE_SSIZE(), 1;
2515  2719             // Syntax: EVE_SSIZE();
2516  2720             // Usage : eg:  print(EVE_SSIZE());
2517  2721             // Notes : Used to get the stack size,
2518  2722             //       : mainly for debugging purposes
2519  2723   
2520  2724   
2521  2725             // uVGAII extended functions
2522  2726             func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
2523  2727             // Syntax: disp_Sync(line);
2524  2728             // Usage : disp_Sync(480);
2525  2729             // Notes : Waits till the hardware gets to a certain line.
2526  2730             //       : Allows the program to synchronise writing to the hardware for flicker free operation.
2527  2731             //       : Some experimentation may be needed to find an optimum line for disp_Sync
2528  2732             //       : depending on the graphics operation. The higher the value, the slower
2529  2733             //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
2530  2734             //       : within the vertical retrace period) where it will just 'hang up' stopping the
2531  2735             //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
2532  2736             //       : be slowest (as its actually right at the end of the blanking period) and 508
2533  2737             //       : will cause a hangup situation as it is above the highes scanline value.
2534  2738             //       : Currently, this function is only supported on displays with SSD1963 driver.
2535  2739   
2536  2740   
2537  2741             // New functions added to PmmC v2.8
2538  2742             //================================================================
2539  2743             func CY(), 1;
2540  2744             // Syntax: CY();
2541  2745             // Usage : myvar := 0xFFF8 + 9;                 // result = 1
2542  2746             //       : print(myvar," "CY(),"\n");           // carry = 1
2543  2747             // Notes : This function returns the carry status of an
2544  2748             // unsigned overflow from any 16 or 32bit additions or sutractions.
2545  2749             //================================================================
2546  2750   
2547  2751   
2548  2752             //================================================================
2549  2753             func str_ByteMove("src", "dest", "count"), 1;
2550  2754             // func str_ByteMove("src", "dest", "count"), 1;
2551  2755             // Syntax   : str_ByteMove(src, dest, bytecount);
2552  2756             // Input    : STR *source points to byte aligned source.
2553  2757             //          : STR *dest   points to byte aligned destination.
2554  2758             //          : VAR count   number of bytes to transfer.
2555  2759             // Usage    : nextpos := str_ByteMove(s, d, 100);
2556  2760             // Notes    : copy bytes from "src" to "dest", stopping only
2557  2761             //          : when "count" is exhausted.
2558  2762             //          : No terminator is appended, it is purely a
2559  2763             //          : byte copy, and any zeroes encountered will
2560  2764             //          : also be copied.
2561  2765             // Returns  : returns a pointer to the end of the destination
2562  2766             //          : (which is "dest" + "count")
2563  2767             //================================================================
2564  2768   
2565  2769   
2566  2770             //================================================================
2567  2771             func str_Copy("dest", "src"), 1;
2568  2772             // Syntax   : str_Copy(dest, src);
2569  2773             // Input    : STR *dest   points to byte aligned destination.
2570  2774             //          : STR *source points to byte aligned source.
2571  2775             // Usage    : nextplace := str_Copy(d, s);
2572  2776             // Notes    : copy a string from "src" to "dest", stopping only
2573  2777             //          : when the end of source string "src" is encountered
2574  2778             //          : (0x00 terminator).
2575  2779             //          : The terminator is always appended, even if "src" is
2576  2780             //          : an empty string.
2577  2781             // Returns  : returns a pointer to the 0x00 string terminator at
2578  2782             //          : end of "dest" (which is "dest" + str_Length(src); )
2579  2783             //================================================================
2580  2784   
2581  2785             //================================================================
2582  2786             func str_CopyN("dest", "src", "count"), 1;
2583  2787             // Syntax   : str_CopyN(dest, src, bytecount);
2584  2788             // Input    : STR *dest   points to byte aligned destination.
2585  2789             //          : STR *source points to byte aligned source.
2586  2790             //          : VAR count   max number of chars to copy.
2587  2791             // Usage    : nextplace := str_CopyN(d, s, 100);
2588  2792             // Notes    : copy a string from "src" to "dest", stopping only
2589  2793             //          : when "count" is exhausted, or end of source
2590  2794             //          : string "str" is encountered (0x00 string terminator).
2591  2795             //          : The terminator is always appended, even if
2592  2796             //          : "count" is zero, or "src" is a null string.
2593  2797             // Returns  : returns a pointer to the 0x00 string terminator
2594  2798             //          : (which is "dest" + whatever was copied)
2595  2799             //================================================================
2596  2800   
2597  2801             //================================================================
2598  2802             func umul_1616("&res32", "val1", "val2"), 1;
2599  2803             // Syntax   : umul_1616(&res32, varA, varB);
2600  2804             // Input    : DWORD *result   points to 32bit result register.
2601  2805             //          : VAR   val1  16bit register or constant
2602  2806             //          : VAR   val2  16bit register or constant
2603  2807             // Usage    : var res32[2];
2604  2808             //          : umul_1616(&res32, myvar, 50000);
2605  2809             // Notes    : performs an unsigned multiply of 2 x 16bit values
2606  2810             //          : placing the 32bit result in a 2 word array.
2607  2811             // Returns  : the pointer to the 32bit result.
2608  2812             //          : carry and overflow are not affected.
2609  2813             //================================================================
2610  2814   
2611  2815             //================================================================
2612  2816             func uadd_3232("&res32", "&val1", "&val2"), 1;
2613  2817             // Syntax   : cmp_3232(&res32, &varA, &varB);
2614  2818             // Input    : DWORD *res32 points to optional result (or zero for compare)
2615  2819             //          : DWORD *val1 points to 32bit augend
2616  2820             //          : DWORD *val2 points to 32bit addend
2617  2821             // Usage    : var res32[2];
2618  2822             //          : res := cmp_3232(res32, val1, val2);
2619  2823             // Notes    : performs an unsigned addition of 2 x 32bit values
2620  2824             //          : placing the 32bit result in a 2 word array.
2621  2825             // Returns  : returns 1 on 32bit unsigned overflow (carry).
2622  2826             //          ; carry flag is also set on 32bit unsigned overflow
2623  2827             //          ; and can be read with the CY() function.
2624  2828             //================================================================
2625  2829   
2626  2830             //================================================================
2627  2831             func usub_3232("&res32", "&val1", "&val2"), 1;
2628  2832             // Syntax   : cmp_3232(&res32, &varA, &varB);
2629  2833             // Input    : DWORD *res32 points to optional result (or zero for compare)
2630  2834             //          : DWORD *val1 points to first 32bit minuend
2631  2835             //          : DWORD *val2 points to 32bit subtrahend
2632  2836             // Usage    : var res32[2];
2633  2837             //          : res := cmp_3232(res32, val1, val2);
2634  2838             // Notes    : performs an unsigned subtraction of 2 x 32bit values
2635  2839             //          : placing the 32bit result in a 2 word array.
2636  2840             // Returns  : returns 1 on 32bit unsigned overflow (borrow).
2637  2841             //          ; carry flag is also set on 32bit unsigned underflow
2638  2842             //          ; and can be read with the CY() function.
2639  2843             //================================================================
2640  2844   
2641  2845             //================================================================
2642  2846             func ucmp_3232("&val1", "&val2"), 1;
2643  2847             // Syntax   : cmp_3232(&varA, &varB);
2644  2848             // Input    : DWORD *val1 points to 32bit minuend
2645  2849             //          : DWORD *val2 points to 32bit sutrahend
2646  2850             // Usage    : res := cmp_3232(val1, val2);
2647  2851             // Notes    : performs an unsigned comparison of 2 x 32bit values.
2648  2852             //          : The result of the subtraction is returned.
2649  2853             // Returns  : 0  if equal
2650  2854             //          : 1  if val1 > val2
2651  2855             //          : -1 if val1 < val2
2652  2856             //          : This function does not affect the carry flag.
2653  2857             //================================================================
2654  2858   
2655  2859             //------------------------------------------------------------------//
2656  2860             // CONSTANTS
2657  2861             //------------------------------------------------------------------//
2658  2862   
2659  2863             // generic constants
2660  2864             #CONST
2661  2873             #END
2662  2874   
2663  2875             //------------------------------------------------------------------------------
2664  2876             // Pin related constants
2665  2877             //------------------------------------------------------------------------------
2666  2878             #CONST
2667  2896             #END
2668  2897   
2669  2898             //------------------------------------------------------------------------------
2670  2899             //gfx_Set() related constants
2671  2900             //------------------------------------------------------------------------------
2672  2901             #CONST
2673  2918             #END
2674  2919   
2675  2920   
2676  2921             //gfx_Get() related constants
2677  2922             #CONST
2678  2931             #END
2679  2932   
2680  2933   
2681  2934   
2682  2935   
2683  2936             #CONST
2684  2949             #END
2685  2950   
2686  2951   
2687  2952             #CONST
2688  2975             #END
2689  2976   
2690  2977             //------------------------------------------------------------------------------
2691  2978             //txt_Set() related constants
2692  2979             //------------------------------------------------------------------------------
2693  2980             #CONST
2694  2999             #END
2695  3000   
2696  3001   
2697  3002   
2698  3003             //------------------------------------------------------------------------------
2699  3004             //txt_Set() related arguments
2700  3005             // NB:- FONT4 must be inherited if required,
2701  3006             // eg #inherit "FONT4.fnt"
2702  3007             //------------------------------------------------------------------------------
2703  3008             #CONST
2704  3020             #END
2705  3021   
2706  3022   
2707  3023   
2708  3024             //touch_Set() related constants
2709  3025             #CONST
2710  3029             #END
2711  3030   
2712  3031             //touch_Get() related constants
2713  3032             #CONST
2714  3040             #END
2715  3041   
2716  3042             // image control offset related constants
2717  3043             #CONST
2718  3050             #END
2719  3051   
2720  3052             // image attribute flags
2721  3053             // for img_SetAttributes(...) and img_ClearAttributes(...)
2722  3054             #CONST
2723  3068             #END
2724  3069   
2725  3070   
2726  3071             #constant ALL 0xFFFF // argument for img_xxx functions to update all images
2727  3071             #constant ALL 0xFFFF // argument for img_xxx functions to update all images
2728  3072   
2729  3073             // image control entry offsets
2730  3074             #CONST
2731  3089             #END
2732  3090   
2733  3091             #CONST
2734  3109             #END
2735  3110   
2736  3111   
2737  3112   
2738  3113   
2739  3114             #CONST
2740  3134             #END
2741  3135   
2742  3136   
2743  3137   
2744  3138             // timer control  related constants
2745  3139             #CONST
2746  3148             #END
2747  3149   
2748  3150             // I2C timing related constants
2749  3151             #CONST
2750  3155             #END
2751  3156   
2752  3157   
2753  3158             // spi_Init(...)  mode arguments
2754  3159             #CONST
2755  3169             #END
2756  3170   
2757  3171             //------------------------------------------------------------------------------
2758  3172             // system WORD variables accesible with peekW and pokeW or pointer access
2759  3173             // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
2760  3174             // can also be accessed with peekW and pokeW
2761  3175             //------------------------------------------------------------------------------
2762  3176   
2763  3177             #CONST
2764  3269             #END
2765  3270   
2766  3271             //------------------------------------------------------------------------------
2767  3272             // FILEIO Error Code Constants
2768  3273             //------------------------------------------------------------------------------
2769  3274             #CONST
2770  3299             #END
2771  3300   
2772  3301             //==================================================================================================
2773  3302   
2774  3303   
2775  3304   
2776  0013                 #ENDIF
2777  0014   
2778  0015   
2779  0016                 #CONST
2780  0072                 #END
2781  0073   
2782  0074   
2783  0075             //===========================================================================================
2784  0076   
2785  0077   
2786  0002   
2787  0003             //#USE DEBUG
2788  0004             #USE TOUCH
2789  0005             #USE ARDUINO
file C:\Programmi\4D Labs\4D Workshop 3 IDE\include\4DGL_16bitColours.fnc

2790  0006             #inherit "4DGL_16bitColours.fnc"
2791  0006             #inherit "4DGL_16bitColours.fnc"
2792  0004             */
2793  0005   
2794  0006   
2795  0007   
2796  0008             #CONST
2797  0149             #END
2798  0150   
file Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts-translation.inc

2799  0007             #inherit "IPX800ts-translation.inc"
2800  0007             #inherit "IPX800ts-translation.inc"
2801  0001   
2802  0002             #CONST
2803  0010             #END
file Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts-config.lib

2804  0008             #inherit "IPX800ts-config.lib"
2805  0008             #inherit "IPX800ts-config.lib"
2806  0001             #constant BASE_CFG, BOARDS_CFG, DEVICES_CFG, WINDOWS_CFG, CONDITIONS_CFG, SCENARIOS_CFG, ARDUINO_CFG
2807  0001             #constant BASE_CFG, BOARDS_CFG, DEVICES_CFG, WINDOWS_CFG, CONDITIONS_CFG, SCENARIOS_CFG, ARDUINO_CFG
2808  0002   
2809  0003             // device types
2810  0004             #constant RELAY, ANALOG, DIGITAL, COUNTER
2811  0004             #constant RELAY, ANALOG, DIGITAL, COUNTER
2812  0005   
2813  0006             var nullstring:="";
2814  0007   
2815  0008             // device usages
2816  0009             #CONST
2817  0026             #END
2818  0027   
2819  0028             var txBuf[20];
2820  0029             var rxBuf[45];
2821  0030   
2822  0031             #constant WINDOW_PATH 3
2823  0031             #constant WINDOW_PATH 3
2824  0032             var wPath[WINDOW_PATH];
2825  0033             var wPathNum:=0;
2826  0034   
2827  0035   
2828  0036             // usage PUSH 1;
2829  0037             func wPush(var wID)
2830  0038              if (wPathNum < WINDOW_PATH )
2831  0039                 wPath[wPathNum++]:=wID;
2832  0040              else return-1;
2833  0041              return 0;
2834  0042             endfunc
2835  0043   
2836  0044             // usage a:=POP;
2837  0045             func wPop()
2838  0046                 if (wPathNum > 0)
2839  0047                     return wPath[--wPathNum];
2840  0048                 else return wPath[wPathNum];
2841  0049             endfunc
2842  0050   
2843  0051             var time[3]; // hour, minutes, seconds
2844  0052             var *date; // year, month, day, dow
2845  0053   
2846  0054   0007 var numVar[9]:=[0,0,0,0,0,0,0,0,0];
2847  00072848  00082849  00092850  000A2851  000B2852  000C2853  000D2854  000E2855  000F2856  00102857  00112858  00122859  00132860  00142861  00152862  00162863  00172864  00182865  0055   
2866  0056   
2867  0057   
2868  0058             // tables
2869  0059             #constant  SYSTEM_TBL, BOARD_TBL, DEVICE_TBL, WINDOW_TBL, CONDITION_TBL, SCENARIO_TBL
2870  0059             #constant  SYSTEM_TBL, BOARD_TBL, DEVICE_TBL, WINDOW_TBL, CONDITION_TBL, SCENARIO_TBL
2871  0060   
2872  0061             // field type
2873  0062             #constant  NUMBER, STRING, CHAR, WORD, IP, SKIP, CHARNUM, NULLSTRING, ncnLIST, UNUMBER, ncLIST
2874  0062             #constant  NUMBER, STRING, CHAR, WORD, IP, SKIP, CHARNUM, NULLSTRING, ncnLIST, UNUMBER, ncLIST
2875  0063   
2876  0066   0019 #END
2877  00192878  001A2879  001B2880  001C2881  001D2882  001E2883  001F2884  00202885  00212886  00222887  00232888  0067   
2889  0068             // system fieldsindex
2890  0069             #constant SYS_ROWS, SYS_COLUMNS
2891  0069             #constant SYS_ROWS, SYS_COLUMNS
2892  0070             // board fields index
2893  0071             #constant B_IP, B_NAME
2894  0071             #constant B_IP, B_NAME
2895  0072             // device fields index
2896  0073             #constant D_BOARD, D_USAGE, D_AIDX, D_BIDX, D_NAME
2897  0073             #constant D_BOARD, D_USAGE, D_AIDX, D_BIDX, D_NAME
2898  0074             // window fields index
2899  0075             #constant W_ICON, W_NAME, W_WIDGETLIST
2900  0075             #constant W_ICON, W_NAME, W_WIDGETLIST
2901  0076             // condition fields index
2902  0077             #constant C_aITEM, C_OPERATOR, C_bITEM
2903  0077             #constant C_aITEM, C_OPERATOR, C_bITEM
2904  0078             // scenario fields index
2905  0079             #constant S_ICON, S_CONF, S_NAME, S_ACTLIST
2906  0079             #constant S_ICON, S_CONF, S_NAME, S_ACTLIST
2907  0080             // widget fields index
2908  0081             //#constant w_WINDOW, w_ACTTYPE, w_ACTARG
2909  0082   
2910  0083             func getType(var tab, var col)
2911  0084             // system rownums
2912  0085   0024     var tbl_system_types[2]:=[ NUMBER, NUMBER];
2913  00242914  00252915  00262916  00272917  0086                 // board IP, board Name
2918  0087   0028     var tbl_board_types[2]:=[ IP, NULLSTRING];
2919  00282920  00292921  002A2922  002B2923  0088                 // dev board, dev type, dev usage, dev Aindex, dev Bindex, dev name
2924  0089   002C     var tbl_device_types[5]:=[ NUMBER, CHAR, NUMBER, NUMBER, STRING];
2925  002C2926  002D2927  002E2928  002F2929  00302930  00312931  00322932  00332933  00342934  00352935  0090                 // window Name, window Icon
2936  0091   0036     var tbl_window_types[3]:=[ NUMBER, STRING, ncLIST];
2937  00362938  00372939  00382940  00392941  003A2942  003B2943  0092                 // condition
2944  0093   003C     var tbl_condition_types[3]:=[ CHARNUM, WORD, CHARNUM];
2945  003C2946  003D2947  003E2948  003F2949  00402950  00412951  0094                 // scenario icon, type + condition, name, action list
2952  0095   0042     var tbl_scenario_types[4]:=[ SKIP, CHARNUM, STRING, ncnLIST];
2953  00422954  00432955  00442956  00452957  00462958  00472959  00482960  00492961  0096   
2962  0097                 var tbl_types[6];
2963  0098                 tbl_types[0]:=tbl_system_types;
2964  0099                 tbl_types[1]:=tbl_board_types;
2965  0100                 tbl_types[2]:=tbl_device_types;
2966  0101                 tbl_types[3]:=tbl_window_types;
2967  0102                 tbl_types[4]:=tbl_condition_types;
2968  0103                 tbl_types[5]:=tbl_scenario_types;
2969  0104   
2970  0105                 var *a;
2971  0106                 a:=tbl_types[tab];
2972  0107                 return a[col];
2973  0108             endfunc
2974  0109   
2975  0110   
2976  0116   004A #END
2977  004A2978  004B2979  004C2980  004D2981  004E2982  004F2983  00502984  00512985  00522986  00532987  00542988  00552989  0117   
2990  0118             //var *boardIP, *boardName;
2991  0119             var *deviceBoard,*deviceUsage,*deviceIndex,*deviceExtra,*deviceName,*deviceStatus;
2992  0120             var *windowName, *windowIcon, *windowWidgetList;
2993  0121             var *scenarioIcon, *scenarioName, *scenarioConf, *scenarioActList;
2994  0122             var *conditionItemA,*conditionOperator,*conditionItemB;
2995  0123   
2996  0124   
2997  0125             //var wIcons:=0; // handle for extra windows icons file
2998  0126             //var sIcons:=0; // handle for extra scenarios icons file
2999  0127   
3000  0128             // config model parameters
3001  0129   
3002  0130             var configModel[1];
3003  0131             var configView[4];
3004  0132             var configControl[4];
3005  0133   
3006  0134             #constant SCRSAVER_TIMEOUT, SCRSAVER_UPD_INTV, SLEEP_TIMEOUT, WIN_UPD_INTV
3007  0134             #constant SCRSAVER_TIMEOUT, SCRSAVER_UPD_INTV, SLEEP_TIMEOUT, WIN_UPD_INTV
3008  0135             #constant ARDUINOPING_INTV, ACTION_DISPATCH_INTV, STATUS_PARSE_INTV, TRIGGER_TEST_INTV
3009  0135             #constant ARDUINOPING_INTV, ACTION_DISPATCH_INTV, STATUS_PARSE_INTV, TRIGGER_TEST_INTV
3010  0136   
3011  0137             var vect_base[3]; //:=[configModel,configView,configControl];
3012  0138             var vect_boards[2];
3013  0139             var vect_devices[5];
3014  0140             var vect_windows[3];
3015  0141             var vect_conditions[3];
3016  0142             var vect_scenarios[4];
3017  0143             //var vect_widgets[3];
3018  0144   
3019  0145   0056 var vect_size[6]:=[3,2,5,3,3,4];
3020  00563021  00573022  00583023  00593024  005A3025  005B3026  005C3027  005D3028  005E3029  005F3030  00603031  00613032  0146   
3033  0147             var confVectors[6]; //:=[vect_base,vect_boards,vect_devices,vect_windows,vect_conditions,vect_scenarios];
3034  0148   
3035  0149   
3036  0150             func getConfArray(var table, var col)
3037  0151   
3038  0152                 var * i;
3039  0153                 i:=confVectors[table];
3040  0154                 if (col >= vect_size[table])
3041  0155                     return -1;
3042  0156                 else return i[col];
3043  0157             endfunc
3044  0158   
3045  0159             func getData(var table, var col, var id)
3046  0160                 var array; array:=getConfArray(table,col);
3047  0161                 var type; type:=getType(table,col);
3048  0162                 var ptr;
3049  0163                 var dataSize; dataSize:=dataLen[type];
3050  0164                 if (dataSize == 1)
3051  0165                     ptr:=str_Ptr(array);
3052  0166                     return str_GetByte(ptr+(dataSize*id));
3053  0167                 else if (dataSize == 2)
3054  0168                     return array[id];
3055  0169                 else return -1;
3056  0170             endfunc
3057  0171   
3058  0172             func setData(var table, var col, var id, var val)
3059  0173                 var array; array:=getConfArray(table,col);
3060  0174                 var type; type:=getType(table,col);
3061  0175                 var ptr;
3062  0176                 var dataSize; dataSize:=dataLen[type];
3063  0177                 if (dataSize == 1)
3064  0178                     ptr:=str_Ptr(array);
3065  0179                     str_PutByte(ptr+(dataSize*id), val);
3066  0180                 else if (dataSize == 2)
3067  0181                     array[id] = val;
3068  0182                 else return -1;
3069  0183   
3070  0184             endfunc
3071  0185   
3072  0186             var *storeFunction:=0;
3073  0187   
3074  0188             #IF USING ARDUINO
3075  0189             func loadArduinoConfig(var line)
3076  0190                 to(COM0); print("set(",[STR] line,")\n");
3077  0191                 while(com_TXcount());
3078  0192   
3079  0193             endfunc
3080  0194             #ENDIF
3081  0195   
3082  0196             func loadBaseConfig(var line)
3083  0197                 var linePtr, cat, idx;
3084  0198                 var *cfgArray;
3085  0199                 linePtr:=str_Ptr(line);
3086  0200                 if (str_GetWZ(&linePtr,&cat)) // get category
3087  0201                     linePtr++;
3088  0202                     cfgArray:=getConfArray(BASE_CFG, cat);
3089  0203                     if (str_GetWZ(&linePtr,&idx)) // get idx
3090  0204                         linePtr++;
3091  0205                         str_GetWZ(&linePtr,&cfgArray[idx]); // save data
3092  0206                     endif
3093  0207                 endif
3094  0208             endfunc
3095  0209   
3096  0210   
3097  0211             func storeRAMConfLine(var tableID, var line, var rowNum)
3098  0212                 var ptr; ptr:=str_Ptr(line);
3099  0213                 var i:=0;
3100  0214                 var j;
3101  0215                 var id;
3102  0216   
3103  0217                 // get current row id
3104  0218                 if(confContainsID[tableID])
3105  0219                     str_GetWZ(&ptr,&id);
3106  0220                     ptr++;
3107  0221                 else
3108  0222                     id:=rowNum;
3109  0223                 endif
3110  0224                 var *vect;
3111  0225                 var colType,pippo,tmp;
3112  0226                 while(getConfArray(tableID,i) >= 0)
3113  0227                      pippo:=0; tmp:=0;
3114  0228                      colType:=getType(tableID,i);
3115  0229                      vect:=getConfArray(tableID,i);
3116  0230                      if (colType == NUMBER)
3117  0231                         str_GetWZ(&ptr,&vect[id]);
3118  0232                      else if (colType == CHAR)
3119  0233                         vect[id]:=str_GetByte(ptr++);
3120  0234                      else if (colType == UNUMBER)
3121  0235                         str_GetWZ(&ptr,&tmp);
3122  0236                         pippo:=str_Ptr(vect[id]);
3123  0237                         str_PutByte(pippo+id,tmp);
3124  0238                      else if (colType == CHARNUM)
3125  0239                         if (! str_GetWZ(&ptr,&pippo)) // only number
3126  0240                             tmp:=str_GetByte(ptr++);
3127  0241                             str_GetWZ(&ptr,&pippo);
3128  0242                         endif
3129  0243                         vect[id]:=tmp << 8 + pippo;
3130  0244                     else if (colType == STRING)
3131  0245                         vect[id]:=mem_AllocZ(str_Length(ptr)+1);
3132  0246                         tmp:= str_Ptr(vect[id]); // gets Name
3133  0247                         while ((str_GetByte(ptr) != ',') && str_Length(ptr))
3134  0248                            str_PutByte(tmp++, str_GetByte(ptr++));
3135  0249                         wend
3136  0250                         str_PutByte(tmp, 0x00);
3137  0251                      else if (colType == WORD)
3138  0252                         vect[id]:= str_GetWord(ptr++); ptr++;
3139  0253                      else if (colType == IP)
3140  0254                         j:=0;
3141  0255                         while(j<2) // gets IP
3142  0256                             str_GetWZ(&ptr,&tmp); ptr++;
3143  0257                             str_GetWZ(&ptr,&pippo); ptr++;
3144  0258                             vect[id*2+j]:=tmp <<8 + pippo;
3145  0259                             j++;
3146  0260                        wend
3147  0261                        ptr--;
3148  0262                     else if (colType == ncnLIST)
3149  0263                         //conta il numero di , nella stringa
3150  0264                         tmp:=ptr;
3151  0265                         pippo:=1;
3152  0266                         while (str_Length(tmp))
3153  0267                             if (str_GetByte(tmp++) == ',') pippo++;
3154  0268                         wend
3155  0269                         //alloca 4*numero di virgole
3156  0270                         vect[id]:=mem_AllocZ(4*pippo);
3157  0271                         // riempi la lista
3158  0272                         tmp:=str_Ptr(vect[id]);
3159  0273                         while (pippo)
3160  0274                             str_GetWZ(&ptr,&j); str_PutByte(tmp++,j); //action condition
3161  0275                             str_PutByte(tmp++, str_GetByte(ptr++));   // action type
3162  0276                             str_GetWZ(&ptr,&j); str_PutWord(tmp,j);   // action argument (2bytes)
3163  0277                             pippo--;
3164  0278                         wend
3165  0279                         else if (colType == ncLIST)
3166  0280                         //conta il numero di , nella stringa
3167  0281                         tmp:=ptr;
3168  0282                         pippo:=1;
3169  0283                         while (str_Length(tmp))
3170  0284                             if (str_GetByte(tmp++) == ',') pippo++;
3171  0285                         wend
3172  0286                         //alloca 2*numero di virgole
3173  0287                         vect[id]:=mem_AllocZ(2*pippo);
3174  0288                         // riempi la lista
3175  0289                         tmp:=str_Ptr(vect[id]);
3176  0290                         while (pippo)
3177  0291                             str_PutByte(tmp++, str_GetByte(ptr++));   // action type
3178  0292                             str_GetWZ(&ptr,&j); str_PutByte(tmp,j);   // action argument
3179  0293                             pippo--;
3180  0294                         wend
3181  0295                     else if (colType == SKIP || colType == NULLSTRING)
3182  0296                         while ((str_GetByte(ptr) != ',') && str_Length(ptr))
3183  0297                             ptr++;
3184  0298                         wend
3185  0299                         if (colType == NULLSTRING) vect[id]:=nullstring;
3186  0300                     endif
3187  0301                     ptr++;
3188  0302                     i++;
3189  0303                 wend
3190  0304             endfunc
3191  0305   
3192  0306             func loadConfFile(var name,var mode)
3193  0307               var confh;
3194  0308               var conffiles[7];
3195  0309                 conffiles[0]:="base.cfg";
3196  0310                 conffiles[1]:="board.cfg";
3197  0311                 conffiles[2]:="device.cfg";
3198  0312                 conffiles[3]:="window.cfg";
3199  0313                 conffiles[4]:="conditio.cfg";
3200  0314                 conffiles[5]:="scenario.cfg";
3201  0315             #IF USING ARDUINO
3202  0316                 conffiles[6]:="arduino.cfg";
3203  0317             #ENDIF
3204  0318             //  print ("Loading ", [STR] conffiles[name]);
3205  0319               var lines:=0;
3206  0320               var t, chr:=0;
3207  0321               var lstchr:=0;
3208  0322               var confl[60];
3209  0323               var p;
3210  0324               var pos:=0;
3211  0325               var comment:=0;
3212  0326             if (file_Exists(conffiles[name]))
3213  0327                     confh := file_Open(conffiles[name],'r');
3214  0328                     while (! file_Error())
3215  0329                         comment:=0;
3216  0330                         //t:=file_GetS(confl, 100, confh); // reads a line from the file
3217  0331                         if ( t:=file_GetS(confl, 119, confh) == 0)
3218  0332                             if (file_Error())
3219  0333                                 break;
3220  0334                             else continue;
3221  0335                         endif
3222  0336                         p:=str_Ptr(confl);
3223  0337                         while(str_Length(p))
3224  0338                             lstchr:= str_GetByte(p);
3225  0339                             if (lstchr == '#') comment:=1;
3226  0340                             if (lstchr == '_') lstchr:='\n';
3227  0341                             if (comment == 1 ) lstchr:=0;
3228  0342                             str_PutByte(p++,lstchr);
3229  0343                         wend
3230  0344                         str_PutByte(p,0x00);
3231  0345                         p:=str_Ptr(confl);
3232  0346                         if( str_Length(p) > 3)
3233  0347                             if (mode == 1)
3234  0348                                 if (name == BASE_CFG)
3235  0349                                     loadBaseConfig(confl);
3236  0350                                 else if (name == ARDUINO_CFG)
3237  0351                                     loadArduinoConfig(confl);
3238  0352                                 else storeFunction(name, confl, lines);
3239  0353                             endif
3240  0354                             lines++;
3241  0355                         endif
3242  0356                       wend
3243  0357                     file_Close(confh);
3244  0358                 endif
3245  0359                 numVar[name]:=lines;
3246  0360                 return lines;
3247  0361             endfunc
3248  0362   
3249  0363             func str_GetWZ(var srcaddr, var dstaddr)
3250  0364              var src; src:=*srcaddr;
3251  0365              var chr;
3252  0366              chr:=str_GetWord(src);
3253  0367              if (LObyte(chr) == '0')
3254  0368                 if (isalnum(HIbyte(chr))) // 0x123, 0b0100011, 0AW
3255  0369                     return str_GetW(srcaddr,dstaddr);
3256  0370                  else // "0," , "0 ", etc
3257  0371                      *dstaddr:=0;
3258  0372                     (*srcaddr)++;
3259  0373                     return 1;
3260  0374                 endif
3261  0375              else // 123, asr3, g4d etc
3262  0376                 return str_GetW(srcaddr,dstaddr);
3263  0377              endif
3264  0378             endfunc
3265  0379   
3266  0380             #IF USING TOUCH
3267  0381             func touchMSG(var msg)
3268  0382                 // wait forever until we get a touch
3269  0383                 var lastColor; lastColor:= peekW(TEXT_COLOUR);
3270  0384                 pokeW(TEXT_COLOUR,RED);
3271  0385                 print(" mem: ", [DEC] mem_Heap(),[STR] msg);
3272  0386                 pokeW(TEXT_COLOUR,lastColor);
3273  0387                 touch();
3274  0388             endfunc
3275  0389   
3276  0390             func touch()
3277  0391                 repeat
3278  0392                     if(touch_Get(TOUCH_STATUS) == TOUCH_PRESSED) break;                    // if there's a press exit
3279  0393                 forever
3280  0394             endfunc
3281  0395             #ENDIF
3282  0396   
3283  0397             func alloc(var name)
3284  0398                 var *array;
3285  0399                 var all, ok:=1;
3286  0400                 var j:=0;
3287  0401                 var lines; lines:=numVar[name];
3288  0402                 var type;
3289  0403                 array:=confVectors[name];
3290  0404                 while( j < vect_size[name])
3291  0405                     type:=getType(name,j);
3292  0406                     if (type == IP)
3293  0407                         all:=lines*4;
3294  0408                     else if (type == UNUMBER)
3295  0409                         all:=lines;
3296  0410                     else all:=lines*2;
3297  0411                     if ( type != SKIP)
3298  0412                         array[j] := mem_AllocZ(all);
3299  0413                         if ( array[j] == 0)
3300  0414                             ok:=0;
3301  0415                         endif
3302  0416                       //  print([DEC] name,[CHR] ',', [DEC] j,[CHR] '@', [DEC] array[j],[CHR] '#',[DEC] alloc,[CHR] '\n'); touchMSG("");
3303  0417                     endif
3304  0418                     j++;
3305  0419                 wend
3306  0420             endfunc
3307  0421   
file Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts-utils.lib

3308  0009             #inherit "IPX800ts-utils.lib"
3309  0009             #inherit "IPX800ts-utils.lib"
3310  0012             */
3311  0013             // images index
3312  0014             #CONST
3313  0065             #END
3314  0066   
3315  0067             var *IMGhndl;
3316  0068   
3317  0069   
3318  0070             func setTimer(var timer, var interval, var function)
3319  0071                 sys_SetTimer(timer,interval);
3320  0072                 sys_SetTimerEvent(timer,function);
3321  0073             endfunc
3322  0074   
3323  0075             func sleepMode()
3324  0076               gfx_Set(CONTRAST,0);
3325  0077             endfunc
3326  0078   
3327  0079             func arduinoReboot()
3328  0080                 pin_HI(IO1_PIN);
3329  0081                 to(COM0);
3330  0082                 putstr("reboot()\n");
3331  0083                 pause(200);
3332  0084                 pin_LO(IO1_PIN);
3333  0085             endfunc
3334  0086   
3335  0087             func screenOn()
3336  0088                 gfx_Set(CONTRAST,1);
3337  0089                 screenSaverActive:=0;
3338  0090   
3339  0091                 setTimer(TIMER1,configView[WIN_UPD_INTV],aWindow.timerEvent); //reenable window update
3340  0092                 sys_SetTimer(TIMER2,configView[SCRSAVER_TIMEOUT]*1000); //reenable screensaver timeout
3341  0093             endfunc
3342  0094   
3343  0095             func putConfig()
3344  0096                 var i:=0;
3345  0097   
3346  0098                 gfx_Panel(PANEL_SUNKEN,30, 80, 260, 80, WHITE);
3347  0099                 gfx_Set(TRANSPARENCY,ON);
3348  0100   
3349  0101                 img(SAVE,35,100,0);
3350  0102                 if (loadConfFile(ARDUINO_CFG,1))
3351  0103                     img(OK,90+i*26,100,0);
3352  0104                 else
3353  0105                     img(NO,90+i*26,100,0);
3354  0106                 endif
3355  0107                 var tmp;
3356  0108                 while( i<numVar[BOARDS_CFG])
3357  0109             //        com_TXbufferHold(ON);
3358  0110                     while(com_TXcount()) ;
3359  0111   
3360  0112                     to(COM0); print("poll(",[DEC] i,",1,");
3361  0113   
3362  0114                     tmp:=0;
3363  0115   
3364  0116                     var *boardIP; boardIP:=getConfArray(BOARDS_CFG,B_IP);
3365  0117                     while (tmp<2)
3366  0118                         var dat; dat:=boardIP[i*2+tmp];
3367  0119                         to(COM0); print([DEC] HIbyte(dat), [CHR] '.', [DEC] LObyte(dat));
3368  0120                         if (tmp == 0)
3369  0121                             to(COM0); putch('.');
3370  0122                         endif
3371  0123                         tmp++;
3372  0124                     wend
3373  0125                    to(COM0); putch(")\n");
3374  0126             //     com_TXbufferHold(OFF);
3375  0127                    // gfx_Set(TRANSPARENCY,ON);
3376  0128                     img(OK,90+i*26,100,0);
3377  0129   
3378  0130                    while(com_TXcount());
3379  0131                    pause(800);
3380  0132                 i++;
3381  0133                 wend
3382  0134   
3383  0135   
3384  0136                 to(COM0); putstr("save()\n");
3385  0137                 pause(1000);
3386  0138                 gfx_Set(TRANSPARENCY,OFF);
3387  0139   
3388  0140             endfunc
3389  0141   
3390  0142             var pingCNT:=0;
3391  0143             func pingArduino()
3392  0144             sys_EventsPostpone();
3393  0145              pingCNT++;
3394  0146              if (pingCNT == configControl[ARDUINOPING_INTV])
3395  0147                  arduinoReboot();
3396  0148                  pingCNT:=0;
3397  0149              endif
3398  0150              sys_SetTimer(TIMER5,60000);
3399  0151              sys_EventsResume();
3400  0152             endfunc
3401  0153   
3402  0154             func reboot()
3403  0155              arduinoReboot();
3404  0156              file_Unmount();
3405  0157              gfx_Set(CONTRAST,0);
3406  0158              SystemReset();
3407  0159             endfunc
3408  0160   
3409  0161             var screenSaverActive:=0;
3410  0162             func screensaver()
3411  0163             sys_EventsPostpone();
3412  0164                 screenSaverActive++;
3413  0165                     sys_SetTimer(TIMER1,0); //block window update
3414  0166                     gfx_Cls();
3415  0167             //        gfx_Panel(PANEL_SUNKEN,0, 0, 320, 240, BLACK);
3416  0168             //        pause(100);
3417  0169                     gfx_MoveTo(ABS(RAND()%200)-40,ABS(RAND()%200));
3418  0170                     txt_FontID(FONT3);
3419  0171                     pokeW(TEXT_COLOUR,GREEN); pokeW(TEXT_BACKGROUND,BLACK);
3420  0172                     pokeW(TEXT_HEIGHT,6); pokeW(TEXT_WIDTH,6);
3421  0173                     print([DEC2Z] time[0], [CHR] ':', [DEC2Z] time[1]);
3422  0174                     pokeW(TEXT_HEIGHT,1); pokeW(TEXT_WIDTH,1);
3423  0175                     if (screenSaverActive > configView[SLEEP_TIMEOUT])
3424  0176                         sleepMode();
3425  0177                     else sys_SetTimer(TIMER2,configView[SCRSAVER_UPD_INTV]*100);
3426  0178                 sys_EventsResume();
3427  0179             endfunc
3428  0180   
3429  0181             func trigger()
3430  0182                 sys_EventsPostpone();
3431  0183                 queueScenario(-'c',-1);
3432  0184                 sys_SetTimer(TIMER4,configControl[TRIGGER_TEST_INTV]*1000);
3433  0185                 sys_EventsResume();
3434  0186             endfunc
3435  0187   
3436  0188             func img(var id, var x, var y, var status)
3437  0189               if (IMGhndl)
3438  0190                 img_SetPosition(IMGhndl, id, x, y);                   // set the checkout box position
3439  0191                 if (status == 1) img_Lighten(IMGhndl,id);
3440  0192                 if (status == -1) img_Darken(IMGhndl,id);
3441  0193                 img_Show(IMGhndl,id);
3442  0194               endif
3443  0195             endfunc
3444  0196   
3445  0197             #IF USING DEBUG
3446 !0198             func printField(var table, var col, var id)
3447 !0199                 var type; type:=getType(table, col);
3448 !0200                 if (type == )
3449 !0201                 else if (type == )
3450 !0202                 endif
3451 !0203             endfunc
3452 !0204   
3453 !0205             func debugNames()
3454 !0206             var i:=0;
3455 !0207             var p:=50000;
3456 !0208   
3457 !0209   
3458 !0210             // boards
3459 !0211             gfx_Cls();
3460 !0212             putstr("BOARDS\n");
3461 !0213             while (i<numVar[BOARDS_CFG])
3462 !0214              print([DEC] i, [CHR] ' ', [STR] boardName[i], [CHR] '\n');
3463 !0215              var      tmp:=0;
3464 !0216   
3465 !0217   
3466 !0218                     while (tmp<2)
3467 !0219                         var dat; dat:=boardIP[i*2+tmp];
3468 !0220                         print([DEC] LObyte(dat), [CHR] '.', [DEC] HIbyte(dat));
3469 !0221                         if (tmp == 0)
3470 !0222                             putch('.');
3471 !0223                         endif
3472 !0224                         tmp++;
3473 !0225                     wend
3474 !0226   
3475 !0227              putch('\n');
3476 !0228              i++;
3477 !0229             wend
3478 !0230             pause(p);
3479 !0231             gfx_Cls();
3480 !0295             pause(p); */
3481 !0296             endfunc
3482  0297             #ENDIF
file Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts-scenario.lib

3483  0010             #inherit "IPX800ts-scenario.lib"
3484  0010             #inherit "IPX800ts-scenario.lib"
3485  0001             var *baseQueue;
3486  0002   
3487  0003             // q_ACTIVEPOS= 16bit,q_CURITEM = 1byte, q_SCENARIO = 2byte
3488  0004             #CONST
3489  0008             #END
3490  0009   
3491  0010             func createQueue(var sID)
3492  0011             // alloca memoria
3493  0012                 var tmp; tmp:= mem_AllocZ(5);
3494  0013             // collega scenario
3495  0014                 setQdata(tmp,q_SCENARIO,sID);
3496  0015             // inizializza posizioni
3497  0016                 setQdata(tmp,q_ACTIVEPOS,0b1111111111111111);
3498  0017                 return tmp;
3499  0018             endfunc
3500  0019   
3501  0020             func getQdata(var *queue, var item)
3502  0021                 var ptr; ptr:=str_Ptr(queue);
3503  0022                 var tmp;
3504  0023                 ptr:=ptr+item;
3505  0024                 if (item == q_CURITEM  || item == q_FORCEDEV)
3506  0025                     return str_GetByte(ptr);
3507  0026                 else if (item == q_ACTIVEPOS )
3508  0027                     return str_GetWord(ptr);
3509  0028                 else
3510  0029                     tmp:=str_GetByte(ptr);
3511  0030   
3512  0031                     if (item == q_sTYPE)
3513  0032                         return HIbyte(scenarioConf[tmp]);
3514  0033                     else if (item == q_sCONDITION)
3515  0034                         return LObyte(scenarioConf[tmp]);
3516  0035                     else return scenarioActList[tmp];
3517  0036                 endif
3518  0037             endfunc
3519  0038   
3520  0039             // item: q_CURITEM, q_ACTIVEPOS, q_SCENARIO
3521  0040             func setQdata(var *queue, var item, var dat)
3522  0041                 var ptr; ptr:=str_Ptr(queue);
3523  0042                 ptr:=ptr+item;
3524  0043                 if (item == q_ACTIVEPOS)
3525  0044                     str_PutWord(ptr,dat);
3526  0045                 else str_PutByte(ptr,dat);
3527  0046             endfunc
3528  0047   
3529  0048             // gets status of a queue's specific position
3530  0049             func getQactPos(var queue, var pos)
3531  0050                 var i; i:=getQdata(queue,q_ACTIVEPOS);
3532  0051                 if ( i & (1<<pos))
3533  0052                     return 1;
3534  0053                 else return 0;
3535  0054             endfunc
3536  0055   
3537  0056             func setQactPos(var queue, var pos, var val)
3538  0057                 var i; i:=getQdata(queue,q_ACTIVEPOS);
3539  0058                 if (val)
3540  0059                     i |= (1 <<pos);
3541  0060                 else
3542  0061                     i &= ~(1<<pos);
3543  0062                 endif
3544  0063                 setQdata(queue, q_ACTIVEPOS, i);
3545  0064             endfunc
3546  0065   
3547  0066             func queueScenario(var sID, var dID)
3548  0067                 queueGenScenario(baseQueue, sID, dID,-1 );
3549  0068             endfunc
3550  0069   
3551  0070             func queueGenScenario(var baseQ, var sID, var dID, var where)
3552  0071              var pos:=where;
3553  0072              if (where == -1) // selezione automatica della posizione dove inserire la coda
3554  0073             // trova prima posizione non attiva (libera) ovv. =0
3555  0074                 pos:=0;
3556  0075                 while(pos<16)
3557  0076                     if (getQactPos(baseQ, pos)) break;
3558  0077                     pos++;
3559  0078                 wend
3560  0079              endif
3561  0080             // alloca ed inizializza coda
3562  0081                 var newQueue;
3563  0082                 newQueue:=createQueue(sID);
3564  0083             // TODO:    setQData(newQueue,q_FORCEDEV,
3565  0084   
3566  0085             //aggiungi a coda principale
3567  0086                 if (testCondition(getQdata(newQueue, q_sCONDITION)))
3568  0087   
3569  0088                     setALitem(baseQ, pos, al_CONDITION, 1); // if condition is tested, set condition to 1
3570  0089                     setALitem(baseQ, pos, al_TYPE, 'j');    // a scenario call is transformed into a action of type Jump
3571  0090                     setALitem(baseQ, pos, al_ARG, newQueue); // the argument of the Jump action is the address of subQueue - IT SHOULD BE 2bytes long....
3572  0091                 endif
3573  0092             endfunc
3574  0093   
3575  0094             // item in al_CONDITION, al_TYPE, al_ARG
3576  0095             func setALitem(var *queue, var aID, var item, var val)
3577  0096                 // estrai la lista azioni
3578  0097                 var curScen; curScen:= getQdata(queue,q_SCENARIO);
3579  0098                 var *curAL; curAL:=scenarioActList[curScen];
3580  0099                 // modifica la posizione in tmpAA
3581  0100                 var ptr; ptr:=str_Ptr(curAL);
3582  0101                 if (item == al_ARG)
3583  0102                     str_PutWord(ptr+(aID*3)+item,val);
3584  0103                 else str_PutByte(ptr+(aID*3)+item,val);
3585  0104             endfunc
3586  0105   
3587  0106             func getALitem(var *queue, var aID, var item)
3588  0107                 // estrai la lista azioni
3589  0108                 var curScen; curScen:= getQdata(queue,q_SCENARIO);
3590  0109                 var *curAL; curAL:=scenarioActList[curScen];
3591  0110                 // modifica la posizione in tmpAA
3592  0111                 var ptr; ptr:=str_Ptr(curAL);
3593  0112                 if (item == al_ARG)
3594  0113                     return str_GetWord(ptr+(aID*3)+item);
3595  0114                 else return str_GetByte(ptr+(aID*3)+item);
3596  0115             endfunc
3597  0116   
3598  0117             func dispatchMainQueueActions()
3599  0118                 sys_EventsPostpone();
3600  0119                 dispatchQueueActions(baseQueue);
3601  0120                 sys_EventsResume();
3602  0121             endfunc
3603  0122   
3604  0123             func dispatchQueueActions(var queue)
3605  0124             // controlla il tipo di coda cui stiamo accedendo (parallela o seriale)
3606  0125                 var qT; qT:=getQdata(queue,q_sTYPE);
3607  0126                 var i:=0;
3608  0127                 if(qT == 'p')
3609  0128             // caso parallelo
3610  0129             //  scorri ogni posizione della coda principale
3611  0130             //      se la posizione  attiva, esegui l'azione contenuta
3612  0131                     while(i<16)
3613  0132                         if (getQactPos(queue,i)) // posizione attiva
3614  0133                              dispatchAction(queue, i);
3615  0134                         endif
3616  0135                         i++;
3617  0136                     wend
3618  0137                 else
3619  0138             // caso seriale
3620  0139             //  trova posizione corrente
3621  0140             //  se la posizione  attiva
3622  0141             //      esegui l'azione contenuta
3623  0142             //  aggiorna
3624  0143                     var curAct; curAct:=getQdata(queue,q_CURITEM);
3625  0144                     if(getQactPos(queue,curAct))
3626  0145                         if (dispatchAction(queue,curAct++)) setQdata(queue,q_CURITEM,curAct%16);
3627  0146                     endif
3628  0147                 endif
3629  0148             // controlla se la coda ha almeno una posizione attiva, altrimenti rimuovila
3630  0149                 if (queue != baseQueue && getQdata(queue,q_ACTIVEPOS) == 0 )
3631  0150                     mem_Free(queue);
3632  0151                     return 1;
3633  0152                 else return 0;
3634  0153             endfunc
3635  0154   
3636  0155             // dispatches a single action
3637  0156             func dispatchAction(var queue, var pos)
3638  0157                 var cond; cond:=getALitem(queue,pos,al_CONDITION);
3639  0158                 var aT; aT:=getALitem(queue,pos,al_TYPE);
3640  0159                 var aA; aA:=getALitem(queue,pos,al_ARG);
3641  0160                 var cleanup:=0;
3642  0161                 if (testCondition(cond))
3643  0162                     if (aT == 's')
3644  0163                         queueGenScenario(queue, aA, -1, pos); //explode scenario
3645  0164                         aT:='j';
3646  0165                         aA:=getALitem(queue,pos,al_ARG); // re.extract data
3647  0166                         // TODO: scenario condition isn't evaluated
3648  0167                     else if (aT == 'w')
3649  0168                      // TODO: decrease wait interval
3650  0169                         cleanup:=(aA <= 0);
3651  0170                     endif
3652  0171   
3653  0172                     if (aT == 'j') // jump to a subqueue
3654  0173                         cleanup:=dispatchQueueActions(aA);
3655  0174                     else if (aT == 'b' || aT == 't' )
3656  0175             //            queueGenScenario(queue, -aT, aA, pos);
3657  0176                     else
3658  0177                         executeAction(aT,aA); // just execute a simple action
3659  0178                         cleanup:=1;
3660  0179                     endif
3661  0180                 endif
3662  0181                 if (cleanup) setQactPos(queue, pos, 0); // set position as inactive
3663  0182                 return cleanup;
3664  0183             endfunc
3665  0184   
3666  0185             func executeAction(var action, var arg)
3667  0186                 var dEX, dBD, dU;
3668  0187                 dEX:=deviceExtra[arg]; dBD:=deviceBoard[arg];
3669  0188                 dU:=deviceUsage[arg];
3670  0189                 if (action == 'd') // down -> pulse HI(deviceIndex[arg])
3671  0190                     controlRelay(dBD, dEX, PULSERELAY);
3672  0191                 else if (action == 'D') // turn on
3673  0192                     controlRelay(dBD, dEX, TURNONRELAY);
3674  0193                 else if  (action == 'p' || action == 'u') // up    -> pulse LO(deviceIndex[arg])
3675  0194                     controlDev(arg, PULSERELAY);
3676  0195                 else if (action == '-') // turn off
3677  0196                     if (dU == GENSTAT || dU==ALARM)
3678  0197                         deviceStatus[arg]:=0;
3679  0198                     else
3680  0199                         controlDev(arg, TURNOFFRELAY);
3681  0200                         if (dU == SHUTTER) controlRelay(dBD, dEX, TURNOFFRELAY);
3682  0201                     endif
3683  0202                 else if (action == '+' || action == 'U') // turn on
3684  0203                     if (dU == GENSTAT || dU==ALARM)
3685  0204                         deviceStatus[arg]:=1;
3686  0205                     else
3687  0206                         controlDev(arg, TURNONRELAY);
3688  0207                     endif
3689  0208                 else if (action == '^') // switch
3690  0209                     if (dU == GENSTAT )
3691  0210                         deviceStatus[arg]:=1-deviceStatus[arg];
3692  0211                     else if (dU == ALARM )
3693  0212                         deviceStatus[arg]:=2;
3694  0213                     else if (dU == LIGHT || dU == APPLIANCE )
3695  0214                         controlDev(arg, SWITCHRELAY);
3696  0215                     endif
3697  0216                 endif
3698  0217             endfunc
3699  0218   
file Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts-control.lib

3700  0011             #inherit "IPX800ts-control.lib"
3701  0011             #inherit "IPX800ts-control.lib"
3702  0001             #CONST
3703  0018             #END
3704  0019   
3705  0020             // select ID from searchFrom where whereType = whereID
3706  0021             func search( var searchFrom, var whereType, var whereID, var *dstArray, var dstSize)
3707  0022                 var *array;
3708  0023                 var results:=0;
3709  0024                 var i:=0;
3710  0025                 array:= getConfArray(searchFrom,whereType);
3711  0026   
3712  0027                 while( i<numVar[searchFrom])
3713  0028                     if ( array[i] == whereID )
3714  0029                       dstArray[results++]:=i;
3715  0030                       if (results == dstSize) break;
3716  0031                     endif
3717  0032                     i++;
3718  0033                 wend
3719  0034             return results;
3720  0035             endfunc
3721  0036   
3722  0037   
3723  0038             func controlDev(var dID, var action)
3724  0039                 controlRelay(deviceBoard[dID],deviceIndex[dID],action);
3725  0040             endfunc
3726  0041   
3727  0042             func controlRelay(var boardID, var relayID, var action)
3728  0043                 to(COM0); print("ipx(",[DEC] boardID, [CHR] ',', [DEC] relayID, [CHR]  ',', [DEC] action, ")\n");
3729  0044                 while(com_TXcount());
3730  0045             endfunc
3731  0046   
3732  0047   
3733  0048             func testCondition(var cID)
3734  0049   
3735  0050               if (cID < 2) return cID;
3736  0051   
3737  0052               var value[2];
3738  0053               var i:=0;
3739  0054               var condIT[2];
3740  0055                 condIT[0]:=conditionItemA[cID];
3741  0056                 condIT[1]:=conditionItemB[cID];
3742  0057                     // extract values to be tested
3743  0058               while (i < 2)
3744  0059                   var itemType, itemValue;
3745  0060   
3746  0061                   itemType:=HIbyte(condIT[i]);
3747  0062                   itemValue:=LObyte(condIT[i]);
3748  0063                   if ( itemType == 0)
3749  0064                       value[i]:= itemValue;
3750  0065                   else if ( itemType == 'd')
3751  0066                       value[i]:= deviceStatus[itemValue];
3752  0067                       if (value[i] == -1) return 0;
3753  0068                   else if ( itemType == 'c')
3754  0069                       value[i]:= testCondition(itemValue);
3755  0070                   else if ( itemType == 'h')
3756  0071             #IF USING DEBUG
3757 !0072                      txt_MoveCursor(0,0); print([DEC] itemValue, [CHR] ':', [DEC] time[0], [CHR] 'H');
3758  0073             #ENDIF
3759  0074                       value[i]:= (time[0] == itemValue);
3760  0075                   else if ( itemType == 'm')
3761  0076             #IF USING DEBUG
3762 !0077                      txt_MoveCursor(0,0); print([DEC] itemValue, [CHR] ':', [DEC] time[1], [CHR] 'M');
3763  0078             #ENDIF
3764  0079                       value[i]:= (time[1] == itemValue && time[2] < (TRIGGER_TEST_INTV*2) ); //test is TRUE only if done in the [0-TRIGGER_TEST_INTV] seconds interval
3765  0080                   endif
3766  0081   
3767  0082                   i++;
3768  0083               wend
3769  0084                 // end extraction
3770  0085                 var op; op:=conditionOperator[cID];
3771  0086                 if (op == '==')
3772  0087                         return (value[0] == value[1] );
3773  0088                 else if (op == '!=') // !=
3774  0089                         return( value[0] != value[1] );
3775  0090                 else if (op == '<=') // <=
3776  0091                         return ( value[0] <= value[1] );
3777  0092                 else if (op == '>=') // >=
3778  0093                         return( value[0] >= value[1] );
3779  0094                 else if (op == ' <')
3780  0095                         return(value[0]  < value[1] );
3781  0096                 else if (op == ' >')
3782  0097                         return( value[0]  > value[1] );
3783  0098                 else if (op == '&&')
3784  0099                         return( value[0] * value[1] );
3785  0100                 else if (op == '||')
3786  0101                         return( value[0] && value[1] );
3787  0102                 else if (op == ' ^')
3788  0103                         return( value[0] || value[1] );
3789  0104                 endif
3790  0105                 return 0;
3791  0106             endfunc
3792  0107   
3793  0108             func parseStatus()
3794  0109             sys_EventsPostpone();
3795  0110                 var str[13];
3796  0111                 var ptr, chr;
3797  0112                 ptr:=str_Ptr(str);
3798  0113   
3799  0114                 while (com_Count())
3800  0115                     chr:=serin();
3801  0116                     if (chr == '\n')
3802  0117                         str_PutByte(ptr,0x00);
3803  0118                         parseStatusLine(str);
3804  0119                         ptr:=str_Ptr(str);
3805  0120                     else
3806  0121                         str_PutByte(ptr++, chr);                // read a byte from COM0
3807  0122                     endif
3808  0123                 wend
3809  0124                 sys_SetTimer(TIMER7,configControl[STATUS_PARSE_INTV]);
3810  0125                 sys_EventsResume();
3811  0126             endfunc
3812  0127   
3813  0128             func parseStatusLine(var *str)
3814  0129                     var ptr; ptr:=str_Ptr(str);
3815  0130                     var id, typ;
3816  0131                     if (str_Length(ptr))
3817  0132   
3818  0133                      if (str_GetWZ(&ptr,&id)) // reads board ID
3819  0134                         ptr++;
3820  0135                         typ:=str_GetByte(ptr); // reads data type a: analog l: leds/relays
3821  0136                         ptr+=2;
3822  0137                         var i;
3823  0138                         if (typ == 'l' || typ == 'a' || typ == 'd')
3824  0139                             i:=1;
3825  0140                             while (str_Length(ptr))
3826  0141                                 var x;
3827  0142                                 str_GetWZ(&ptr,&x);
3828  0143                                 updateDevice(id,typ,i++,x);
3829  0144                                 ptr++;
3830  0145                             wend
3831  0146                         endif
3832  0147                         if (typ == 't' && id==0)
3833  0148                              i:=0;
3834  0149                              while (i<3)
3835  0150                                 str_GetWZ(&ptr,&time[i]);
3836  0151                                 ptr++; i++;
3837  0152                              wend
3838  0153                         endif
3839  0154                     endif
3840  0155   
3841  0156                   endif
3842  0157             endfunc
3843  0158   
3844  0159             func updateDevice(var boardID, var devtype, var devidx, var dat)
3845  0160                 var searchRes[15];
3846  0161                 var resNum,i;
3847  0162                 resNum:= search(DEVICES_CFG, D_BOARD, boardID, searchRes, 15);
3848  0163                 i:=0;
3849  0164                 while(i<resNum)
3850  0165                     var curItem; curItem:=searchRes[i];
3851  0166                     if (deviceIndex[curItem] == devidx)
3852  0167                         var dU; dU:=deviceUsage[curItem];
3853  0168                         if (devtype == 'l')
3854  0169                             if ( dU == APPLIANCE || dU == LIGHT )
3855  0170                                 deviceStatus[curItem]:=dat;
3856  0171                                 break;
3857  0172                             endif
3858  0173                         else if (devtype == 'a')
3859  0174                             if ( dU == TEMP || dU == LIGHTX || dU == TEMPX || dU == VOLTAGE || dU == HUMID )
3860  0175                                 deviceStatus[curItem]:=dat;
3861  0176                                 break;
3862  0177                             endif
3863  0178                         else if (devtype == 'd')
3864  0179                             if ( dU == BUTTON)
3865  0180                                 deviceStatus[curItem]:=dat;
3866  0181                             endif
3867  0182                         endif
3868  0183                     endif
3869  0184                     i++;
3870  0185                 wend
3871  0186             endfunc
3872  0187   
3873  0188   
file Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts-gui.lib

3874  0012             #inherit "IPX800ts-gui.lib"
3875  0012             #inherit "IPX800ts-gui.lib"
3876  0001             // colour scheme
3877  0002             #CONST
3878  0006             #END
3879  0007   
3880  0008             #constant MAXBUTTONS 12      // 12 iconed pushbuttons + exit buttun
3881  0008             #constant MAXBUTTONS 12      // 12 iconed pushbuttons + exit buttun
3882  0009   
3883  0010             // enumeration for the window's sub functions
3884  0011             #constant INITIALIZE, UPDATE, SCAN
3885  0011             #constant INITIALIZE, UPDATE, SCAN
3886  0012   
3887  0013   
3888  0014             func windowUpdate()
3889  0015              aWindow(UPDATE);
3890  0016             endfunc
3891  0017   
3892  0018             //
3893  0019             func iconedButton(var vButtonID)
3894  0020             //    var private icon:=-1;
3895  0021                 var private text:=0;
3896  0022                 var private id:=0;
3897  0023                 var type, ID;
3898  0024                 var private sensstr[6];
3899  0025                 sensstr[0]:=0;
3900  0026                 type:=aWindow.vButtonActType[vButtonID];
3901  0027                 ID:=aWindow.vButtonActArg[vButtonID];
3902  0028                 text:=nullstring;
3903  0029                 if (type == WINDOW || type == BACK) // we're talking about windows..
3904  0030                     if (ID == -SHUTTER)
3905  0031                         text:=nullstring;
3906  0032                         id:=SHUTTER_ICON;
3907  0033                     else if (ID == -APPLIANCE)
3908  0034                         text:=nullstring;
3909  0035                         id:=PLUG_UNKNOWN;
3910  0036                     else if (ID == -LIGHT)
3911  0037                         text:=nullstring;
3912  0038                         id:=LIGHT_UNKNOWN;
3913  0039                     else if (ID == 254)
3914  0040                         text:="Reboot";
3915  0041                         id:=REFRESH;
3916  0042                     else if (ID == 255)
3917  0043                         text:="Save";
3918  0044                         id:=SAVE;
3919  0045                     else
3920  0046                         text:=windowName[ID];
3921  0047                         id:=windowIcon[ID];
3922  0048                     endif
3923  0049                 endif
3924  0050                 if (type == DEVICE) // we're talking about devices
3925  0051                     text:=deviceName[ID];
3926  0052                     var devUsage, devStat, devExtra, calc, res;
3927  0053                     devUsage:=deviceUsage[ID];
3928  0054                     devStat:=deviceStatus[ID];
3929  0055                     devExtra:=deviceExtra[ID];
3930  0056                     if (devUsage == ALARM)
3931  0057                             if (devStat == 0)
3932  0058                                 id:=OK;       //                  ok_icon(x+16,y+16);
3933  0059                             else if (devStat == 1)
3934  0060                                 id:=STAT_ON;          //               staton_icon(x+16,y+16);
3935  0061                             else if (devStat == -1)
3936  0062                                 id:=STAT_UNKNOWN;    //                     statunknown_icon(x+16,y+16);
3937  0063                             else
3938  0064                                 id:=NO;       //                  no_icon(x+16,y+16);
3939  0065                             endif
3940  0066   
3941  0067                     else if (devUsage == GENSTAT)
3942  0068                         id:=STAT_UNKNOWN;
3943  0069                         if ( devStat >=0) id:=devExtra+devStat;
3944  0070                     else if (devUsage == LIGHT)
3945  0071                         if (devExtra != 0)
3946  0072                              id:=devExtra+devStat;
3947  0073                         else id:=LIGHT_OFF+(devStat);
3948  0074                     else if (devUsage == APPLIANCE)
3949  0075                         if (devExtra != 0)
3950  0076                             id:=devExtra+devStat;
3951  0077                         else id:=PLUG_OFF+devStat;
3952  0078                     else if (devUsage == SHUTTER)
3953  0079                         id:=SHUTTER_ICON;   // shutter_icon(x,y);
3954  0080                     else if (devUsage == PULSE)
3955  0081                         id:=PULSE_ICON;// pulse_icon(x,y);
3956  0082                     else if (devUsage == BUTTON)
3957  0083                         id:=BTN_OFF+devStat;
3958  0084                     else // devices that need some calculation
3959  0085                         to(sensstr);
3960  0086                         if (devUsage == MEMHEAP)
3961  0087                             id:=SENSORS;
3962  0088                             devStat:=1;
3963  0089                             putnum(DEC, mem_Heap());
3964  0090                         else if (devUsage == TIME)
3965  0091                             id:=DEVICE_ICON;
3966  0092                             devStat:=1;
3967  0093             #IFNOT USING DEBUG
3968  0094                             print([DEC2Z] time[0], [CHR] ':',[DEC2Z] time[1], [CHR] ':',[DEC2Z] time[2]);
3969  0095             #ENDIF
3970  0096                         else if (devUsage == TEMP)
3971  0097                             id:=TEMPERATURESENS; //         temperature_icon(x,y);
3972  0098                             calc:=(devStat * 10 - 1551);
3973  0099                             res:=(calc%31) *10;
3974  0100             #IFNOT USING DEBUG
3975  0101                             print( [CHR] ' ', [DEC2] calc/31, [CHR] '.', [DEC1] res/31 );
3976  0102             #ENDIF
3977  0103                         else if (devUsage == TEMPX)
3978  0104                             id:=TEMPERATURESENS;//
3979  0105                             calc:=(devStat * 33 - 16691 );
3980  0106                             res:=(calc%333) *10;
3981  0107             #IFNOT USING DEBUG
3982  0108                             print( [CHR] ' ', [DEC2] calc/333, [CHR] '.', [DEC1] res/333);
3983  0109             #ENDIF
3984  0110                         else if (devUsage == LIGHTX)
3985  0111                             id:=LIGHT_UNKNOWN;//
3986  0112                             calc:=(devStat * 39 ) ;
3987  0113                             res:=(calc%399) *10;
3988  0114             #IFNOT USING DEBUG
3989  0115                             print( [CHR] ' ', [DEC2] calc/399,[CHR] '.', [DEC1] res/399, [CHR] '%');
3990  0116             #ENDIF
3991  0117                         else if (devUsage == HUMID)
3992  0118                             id:=HUMIDITYSENS;//         temperature_icon(x,y);
3993  0119                             calc:=(devStat * 10 - 1551 ) / 65;
3994  0120             #IFNOT USING DEBUG
3995  0121                             print ([CHR] ' ', [DEC2] calc, [CHR] '%');
3996  0122             #ENDIF
3997  0123                         else if (devUsage == VOLTAGE)
3998  0124                             id:=VOLTSENS;//         temperature_icon(x,y);
3999  0125                             calc:=(devStat * deviceExtra[ID]);
4000  0126                             res:=(calc%1024)*10;
4001  0127             #IFNOT USING DEBUG
4002  0128                             print( [CHR] ' ', [DEC] calc/1024, [CHR] '.', [DEC1] res/1024, [CHR] 'V' );
4003  0129             #ENDIF
4004  0130                         endif
4005  0131                     endif
4006  0132                     if (devStat < 0 ) sensstr[0]:=0;
4007  0133                 //we're talking about scenarios
4008  0134                 else if (type == SCENARIO)
4009  0135                     if (ID < 0)
4010  0136                         if (ID == -'d')
4011  0137                             text:=SDOWN;
4012  0138                             id:=DOWN_ICON;
4013  0139                         else if (ID == -'u')
4014  0140                             text:=SUP;
4015  0141                             id:=UP_ICON;
4016  0142                         else if (ID == -'t')
4017  0143                              text:=STOP;
4018  0144                             id:=TOP_ICON;
4019  0145                         else if (ID == -'b')
4020  0146                             text:=SBOTTOM;
4021  0147                             id:=BOTTOM_ICON;
4022  0148                         endif
4023  0149                     else
4024  0150                         text:=scenarioName[ID];
4025  0151                         id:=SCEN1;//   scenarios1_icon(x,y);
4026  0152                     endif
4027  0153                 endif
4028  0154   
4029  0155             endfunc
4030  0156   
4031  0157             func prepareWindow(var wID)
4032  0158                 placeWindow(0,0,320,240,16,16,4,windowUpdate,configView[WIN_UPD_INTV],-1);
4033  0159   
4034  0160             //    if (wID <= -APPLIANCE && wID >= -122) // shutter list
4035  0161             //         prepareButtons(DEVICES_CFG, D_USAGE, -wID,'d');
4036  0162             //    else prepareButtons(WIDGETS_CFG, w_WINDOW, wID, 0);
4037  0163   
4038  0164                 if ( wID != 0 )
4039  0165                     addButton(MAXBUTTONS-1, BACK, wPop());
4040  0166                     wPush(aWindow.vButtonActArg[MAXBUTTONS-1]);
4041  0167                 else
4042  0168   
4043  0169                 // add predefined link in main window
4044  0170                     addButton(MAXBUTTONS-1,WINDOW,1);
4045  0171                     wPush(wID);
4046  0172                 endif
4047  0173   
4048  0174                return wID;
4049  0175             endfunc
4050  0176   
4051  0177             func addButton(var pos, var act, var arg)
4052  0178                 aWindow.vButtonActType[pos]:=act;
4053  0179                 aWindow.vButtonActArg[pos]:=arg;
4054  0180                 aWindow.vButtonTouchable[pos]:=1;
4055  0181             endfunc
4056  0182   
4057  0183   
4058  0184             func prepareButtons(var wID, var forceActType)
4059  0185                 var *searchRes; searchRes:=getConfVect(WINDOWS_CFG,W_WIDGETLIST,wID);
4060  0186                 var resNum; resNum:=sizeof(searchRes);
4061  0187                 var i:=0;
4062  0188   
4063  0189                 while (i<MAXBUTTONS && i<resNum)
4064  0190                     if (i<resNum)
4065  0191                         var curItem; curItem:=searchRes[i];
4066  0192                         if ( forceActType != 0)
4067  0193                             addButton(i,forceActType,LObyte(curItem));
4068  0194                         else
4069  0195                             addButton(i,HIbyte(curItem),LObyte(curItem));
4070  0196                         endif
4071  0197                     else
4072  0198                         addButton(i,NONE,0);
4073  0199                         aWindow.vButtonTouchable[i]:=0;
4074  0200                     endif
4075  0201                     i++;
4076  0202                 wend
4077  0203             endfunc
4078  0204   
4079  0205             func placeWindow(var x, var y, var w, var h, var xG, var yG, var grid, var tE, var tT, var dID)
4080  0206                 aWindow.windowWidth:=w;
4081  0207                 aWindow.windowHeight:=h;
4082  0208                 aWindow.xpos := x;
4083  0209                 aWindow.ypos := y;
4084  0210                 aWindow.xgap :=xG;
4085  0211                 aWindow.ygap :=yG;
4086  0212                 aWindow.xgrid:=grid;
4087  0213                 aWindow.timerEvent:=tE;
4088  0214                 aWindow.timer:=tT;
4089  0215                 aWindow.dID:=dID;
4090  0216   
4091  0217             endfunc
4092  0218   
4093  0219             func preparePopUp(var wID, var dID)
4094  0220                 placeWindow(80,40,160,170,16,14,2,0,0,dID);
4095  0221   
4096  0222             //   prepareButtons(WINDOWS_CFG, W_WIDGETLIST, wID, 0);
4097  0223   
4098  0224                return wID;
4099  0225             endfunc
4100  0226   
4101  0227             // example for a simple Window object
4102  0228             func aWindow(var subfunc)
4103  0229   
4104  0230                 // window properties
4105  0231                 var private xpos, ypos;                         // window position
4106  0232                 var private windowWidth;                 // default window width
4107  0233                 var private windowHeight;                // default window height
4108  0234                 var windowcolor := WINDOW_COLOR;        // default window colour
4109  0235   
4110  0236                 var textcolor := BLACK;                 // default text colour
4111  0237                 var private xgap;                        // horizontal gap between buttons
4112  0238                 var private ygap;                         // vertical gap between buttons
4113  0239                 var private xgrid;
4114  0240                 var private touchX1[MAXBUTTONS];                // touch regions for the buttons
4115  0241                 var private touchY1[MAXBUTTONS];
4116  0242                 var private touchX2[MAXBUTTONS];
4117  0243                 var private touchY2[MAXBUTTONS];
4118  0244                 var private vButtonActType[MAXBUTTONS];
4119  0245                 var private vButtonActArg[MAXBUTTONS];
4120  0246                 var private vButtonTouchable[MAXBUTTONS];
4121  0247                // var private vButtonText[MAXBUTTONS];
4122  0248                 var private dID;
4123  0249                 var private lastkey;                            // last button pressed
4124  0250                 var private timerEvent;
4125  0251                 var private timer;
4126  0252                 var private touchState;                         // window touch status
4127  0253                 var touchX;                             // window x position
4128  0254                 var touchY;                             // window y position
4129  0255                 var private touchEpoch;
4130  0256                 // local variables
4131  0257                 var n, r, retval;
4132  0258   
4133  0259                 txt_FontID(FONT1);
4134  0260   
4135  0261                 // functions methods
4136  0262                 if (subfunc != SCAN)     sys_EventsPostpone();
4137  0263   
4138  0264                 gosub(subfunc), (Initialize, Update, Scan);
4139  0265   
4140  0266                 // restore things we changed
4141  0267                 goto exitfunc;
4142  0268   
4143  0269                 //--------------------------------------------------
4144  0270                 // reset the window and redraw the buttons to the up state
4145  0271                 //--------------------------------------------------
4146  0272                 Initialize:
4147  0273                     //touch_Set(TOUCH_ENABLE); // enable the touch screen
4148  0274                     //gfx_Cls();
4149  0275   
4150  0276                     n:=0;
4151  0277                     while(n<MAXBUTTONS)
4152  0278                         if (vButtonTouchable[n] != 0)
4153  0279                             touchX1[n] := xpos + (64+xgap)*(n%xgrid)+ xgap/4;
4154  0280                             touchY1[n] := ypos + (64+ygap)*(n/xgrid);                                  // set the position of the first button offset in the window
4155  0281                             touchX2[n] := touchX1[n]+64;
4156  0282                             touchY2[n] := touchY1[n]+64;
4157  0283                         endif
4158  0284                         n++;
4159  0285                     wend
4160  0286   
4161  0287                     gfx_Panel(PANEL_RAISED, xpos, ypos, windowWidth, windowHeight, windowcolor);        // draw main window panel
4162  0288   
4163  0289                     gosub Update;
4164  0290   
4165  0293                     */
4166  0294                     screenOn();
4167  0295   
4168  0296                     endsub;
4169  0297   
4170  0298                 //--------------------------------------------------
4171  0299                 // Update any buttons that have changed state
4172  0300                 //--------------------------------------------------
4173  0301                 Update:
4174  0302   
4175  0303                      pokeW(TEXT_COLOUR,textcolor);
4176  0304                      pokeW(TEXT_BACKGROUND,windowcolor);
4177  0305   
4178  0306                      n:=0;
4179  0307                      while(n<MAXBUTTONS)
4180  0308                         if ( vButtonTouchable[n] != 0)
4181  0309                             iconedButton(n);
4182  0310                             img(iconedButton.id,touchX1[n],touchY1[n],0);
4183  0311                             gfx_MoveTo(touchX1[n],touchY2[n]);
4184  0312                             putstr(iconedButton.text);
4185  0313                             putstr(iconedButton.sensstr);
4186  0314                         endif
4187  0315                         n++;
4188  0316                     wend
4189  0317   
4190  0320                     */
4191  0321                     sys_SetTimer(TIMER1,timer);
4192  0322                     sys_EventsResume();
4193  0323   
4194  0324   
4195  0325                 endsub;
4196  0326   
4197  0327                 //--------------------------------------------------
4198  0328                 // scan for any button presses
4199  0329                 //--------------------------------------------------
4200  0330                 Scan:
4201  0331                 touchState := touch_Get(TOUCH_STATUS);                  // save touchscreen status
4202  0332                 touchX := touch_Get(TOUCH_GETX);                        // and current position
4203  0333                 touchY := touch_Get(TOUCH_GETY);
4204  0334   
4205  0335                 // if screen touched,
4206  0336                 if(touchState == TOUCH_PRESSED)
4207  0337                     if (screenSaverActive > 0)
4208  0338                         gosub Initialize;
4209  0339                     else
4210  0340                         screenOn();
4211  0341   
4212  0342                     // scan the hot spots list
4213  0343                         while (n < MAXBUTTONS && !r)
4214  0344                             if (vButtonTouchable[n] != 0)
4215  0345                                 if (touchX >= touchX1[n] && touchX < touchX2[n] && touchY >= touchY1[n] && touchY < touchY2[n]) r := n+1;
4216  0346                             endif
4217  0347                             n++;
4218  0348                         wend
4219  0349   
4220  0350                         // if any button was pressed
4221  0351                         if(r)
4222  0352                             lastkey := r;                                   // remeber the button
4223  0353                             iconedButton(r-1);
4224  0354                             img(iconedButton.id,touchX1[r-1],touchY1[r-1],-1);
4225  0355   
4226  0356                             touchEpoch:=sys_T();
4227  0357                         endif
4228  0358                     endif
4229  0359                 else
4230  0360                 if((touchState == TOUCH_RELEASED) && lastkey)           // if touch released and we remember a previous button press,
4231  0361                     if (touchEpoch + 2000 < sys_T())
4232  0362                         retval:=-lastkey;
4233  0363                     else retval := lastkey;                                  // set return value with the button number
4234  0364   
4235  0365                     lastkey := 0;                                       // clear button memory
4236  0366                     endif
4237  0367                 endif
4238  0368                 endsub;
4239  0369   
4240  0370             exitfunc:
4241  0371                 return retval;
4242  0372             endfunc
4243  0373   
4244  0374             // call some asynchronous action OR draw another window
4245  0375             // defaultUsage == 1 ? then execute actions using curItem as argument.
4246  0376             func onShortClick(var vButtonID, var dID)
4247  0377                 var actType, id;
4248  0378                 actType:=aWindow.vButtonActType[vButtonID];
4249  0379                 id:=aWindow.vButtonActArg[vButtonID];
4250  0380                 if (actType==DEVICE)
4251  0381                     var devUsage;
4252  0382                     devUsage:=deviceUsage[id];
4253  0383                     if (devUsage ==LIGHT || devUsage ==APPLIANCE)
4254  0384                         queueScenario(-'2',id); // switch device
4255  0385                     else if (devUsage == PULSE)
4256  0386                         queueScenario(-'p',id); // pulse device
4257  0387                     else if  (devUsage ==SHUTTER)
4258  0388                                     preparePopUp(-SHUTTER,id);
4259  0389                                     aWindow(INITIALIZE);
4260  0390   
4261  0391                                     var selected;
4262  0392                                     repeat
4263  0393                                         selected:=aWindow(SCAN);
4264  0394                                         if (selected)
4265  0395                                             onShortClick(ABS(selected)-1,aWindow.dID);
4266  0396                                             break;
4267  0397                                         endif
4268  0398                                     forever
4269  0399                                     // restore previuos Window
4270  0400                                     prepareWindow(wPop());
4271  0401                                     aWindow(INITIALIZE);
4272  0402                     else if ( devUsage == GENSTAT)
4273  0403                         if (deviceExtra[id]) queueScenario(-'2',id); // device index = 1 means: writable by user.
4274  0404                     endif
4275  0405                 else
4276  0406                     if (actType==WINDOW)
4277  0407                     // insert here specific windows behaviour
4278  0408                         if (id == -114) reboot();   // reboot
4279  0409                         if (id == -83)  putConfig();           //saveconfig
4280  0410   
4281  0411                         wPush(prepareWindow(id));
4282  0412                         aWindow(INITIALIZE);
4283  0413                     else if (actType==SCENARIO)
4284  0414                            queueScenario(id, dID);
4285  0415                     else if (actType == BACK )
4286  0416                                 wPop();
4287  0417                                 prepareWindow(wPop());
4288  0418                                 aWindow(INITIALIZE);
4289  0419                     endif
4290  0420   
4291  0421                 endif
4292  0422             endfunc
4293  0423   
4294  0424             func onLongClick(var vButtonID, var dID)
4295  0425                 var actType, id;
4296  0426                 actType:=aWindow.vButtonActType[vButtonID];
4297  0427                 id:=aWindow.vButtonActArg[vButtonID];
4298  0435                 endif */
4299  0436             endfunc
4300  0437   
4301  0013   
4302  0014   
4303  0015             func main()
4304  0016                 boot();
4305  0017             #IF USING DEBUG
4306 !0018                 gfx_Cls();
4307 !0019                 debugNames();
4308  0020             #ENDIF
4309  0021                 wPush(prepareWindow(0));
4310  0022                 aWindow(INITIALIZE);
4311  0023                 var selected;
4312  0024                 repeat
4313  0025                  selected:=aWindow(SCAN);
4314  0026                  if (selected > 0) onShortClick(selected-1,-1);
4315  0027             //     if (selected < 0) onLongClick(ABS(selected)-1,-1);
4316  0028                 forever
4317  0029             endfunc
4318  0030   
4319  0031             func boot()
4320  0032                 gfx_ScreenMode(LANDSCAPE);
4321  0033                 touch_Set(TOUCH_ENABLE);
4322  0034                 gfx_Set(TRANSPARENT_COLOUR,WHITE); // transparency works with WHITE
4323  0035   
4324  0036                 com_SetBaud(COM0,5760);
4325  0037                 com_Init(rxBuf,89,0);
4326  0038                 com_TXbuffer(txBuf, 40);    // sets the buffer location for buffered transmission
4327  0039                 storeFunction:=storeRAMConfLine;
4328  0040   
4329  0041                 vect_base[0]:=configModel; vect_base[1]:=configView; vect_base[2]:=configControl;
4330  0042   
4331  0043                 confVectors[0]:=vect_base; confVectors[1]:=vect_boards; confVectors[2]:=vect_devices; confVectors[3]:=vect_windows;
4332  0044                 confVectors[4]:=vect_conditions; confVectors[5]:= vect_scenarios;
4333  0045   
4334  0046                 pokeW(TEXT_COLOUR,BLACK);
4335  0047                 pokeW(TEXT_BACKGROUND,WHITE);
4336  0048                 IMGhndl:= file_LoadImageControl("ICONS.DAT", "ICONS.GCI",0);             // use fast mode 1 for this type of work
4337  0049                 img_Enable(IMGhndl, ALL);                        // first, disable all the images (ALL = -1), makes it easier to set up if we only need a few
4338  0050   
4339  0051                 var i:=0;
4340  0052                 while( i<48)
4341  0053                     img(BG_GREY, 40*(i%8),40*(i/8),0);                   // set the checkout box position
4342  0054                     i++;
4343  0055                 wend
4344  0056   
4345  0057                 gfx_Panel(PANEL_SUNKEN,40,60,240,120,WHITE);
4346  0058                 var ypos:=82;
4347  0059                 pokeW(TEXT_OPACITY, OPAQUE);
4348  0060                 img(OFFICE_SMALL,40,ypos,0);
4349  0061                 gfx_MoveTo(43,140);
4350  0062                 putstr("Loading...");
4351  0063   
4352  0064                 var error:=0;
4353  0065                 var mode:=0;
4354  0066                 gfx_Set(TRANSPARENCY,ON);
4355  0067   
4356  0068                 while (mode<2)
4357  0069                     i:=BASE_CFG;
4358  0070                     while( i<=SCENARIOS_CFG )
4359  0071                         if (loadConfFile(i,mode))
4360  0072                             touchMSG("ok");
4361  0073                             img(OK,70+i*25,ypos,mode);//            ok_icon(46+i*25,ypos);
4362  0074                         else
4363  0075                             error:=1;
4364  0076                             img(NO,70+i*25,ypos,0); //           no_icon(46+i*25,ypos);
4365  0077                         endif
4366  0078                         touch();
4367  0079                         i++;
4368  0080                     wend
4369  0081   
4370  0082                     if (error)
4371  0083                         pause(10000);
4372  0084                         SystemReset();
4373  0085                     endif
4374  0086   
4375  0087                     if (mode == 0)
4376  0088                         i:=BOARDS_CFG;
4377  0089                         while( i<=SCENARIOS_CFG )
4378  0090                             alloc(i++);
4379  0091                         wend
4380  0092                     endif
4381  0093                     mode++;
4382  0094                 wend
4383  0095   
4384  0096                 i:=0;
4385  0097   
4386  0098                 deviceBoard:=vect_devices[0]; deviceUsage:=vect_devices[1]; deviceIndex:=vect_devices[2]; deviceExtra:=vect_devices[3]; deviceName:=vect_devices[4];
4387  0099              //   boardIP:=vect_boards[0]; boardName:=vect_boards[1];
4388  0100                 conditionItemA:=vect_conditions[0]; conditionOperator:=vect_conditions[1]; conditionItemB:=vect_conditions[2];
4389  0101              //   actionScenario:=vect_actions[0]; actionType:=vect_actions[1]; actionArg:=vect_actions[2]; actionCondition:=vect_actions[3];
4390  0102                 windowIcon:=vect_windows[0]; windowName:=vect_windows[1]; windowWidgetList:=vect_windows[2];
4391  0103              //   widgetWindow:=vect_widgets[0]; widgetActType:=vect_widgets[1]; widgetActArg:=vect_widgets[2];
4392  0104                 //scenarioIcon:=vect_scenarios[0];
4393  0105   
4394  0106                 scenarioConf:=vect_scenarios[1]; scenarioName:=vect_scenarios[2]; scenarioActList:=vect_scenarios[3];
4395  0107   
4396  0108                 deviceStatus:=mem_AllocZ(2*numVar[DEVICES_CFG]);
4397  0109   
4398  0110                 while (i< numVar[DEVICES_CFG])
4399  0111                     deviceStatus[i++]:=-1;
4400  0112                 wend
4401  0113   
4402  0114                 gfx_Set(TRANSPARENCY, OFF);
4403  0115   
4404  0116                 setTimer(TIMER0,500,dispatchMainQueueActions);
4405  0117                 sys_SetTimerEvent(TIMER2,screensaver); // set screensaver action
4406  0118                 setTimer(TIMER4,configControl[TRIGGER_TEST_INTV]*1000,trigger);
4407  0119                 setTimer(TIMER5,60000,pingArduino); // set action for screen offr
4408  0120                 setTimer(TIMER7,200,parseStatus);
4409  0121   
4410  0122                 baseQueue:=createQueue(0);
4411  0123                 queueScenario(-'S',-1);
4412  0124             endfunc
4413  0125   
Notice: no execution path to func 'onLongClick'
Notice: function argument 'dID' in func 'onLongClick' is never used (line 424 file:IPX800ts-gui.lib)
Notice: no execution path to func 'prepareButtons'
Notice: function argument 'dID' in func 'queueGenScenario' is never used (line 70 file:IPX800ts-scenario.lib)
Notice: Check that the function called via pointer  'storeFunction' requires 3 arguments (line 352 file:IPX800ts-config.lib)
Notice: no execution path to func 'setData'
Notice: no execution path to func 'getData'


Symbol Table:
name                 decimal    hex
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (usage 3)
addButton                           2002  0x000007d2 (User func) args[3] r=0  (usage 5)
al_ARG                                 7  0x00000007 (const ??? 0)  (usage 5)
al_CONDITION                           5  0x00000005 (const ??? 0)  (usage 2)
al_TYPE                                6  0x00000006 (const ??? 0)  (usage 2)
ALARM                                 65  0x00000041 (const dword)  (usage 4)
ALL                                65535  0x0000ffff (const dword)  (usage 1)
alloc                               6715  0x00001a3b (User func) args[1] r=0  (usage 1)
APPLIANCE                             97  0x00000061 (const dword)  (usage 5)
ARDUINO                                0  0x00000000 (set)  (usage 2)
ARDUINO_CFG                            6  0x00000006 (const ??? 0)  (usage 2)
ARDUINOPING_INTV                       0  0x00000000 (const ??? 0)  (usage 1)
arduinoReboot                       6631  0x000019e7 (User func) args[0] r=0  (usage 2)
aWindow                             1282  0x00000502 (User func) args[1] r=0  (usage 8)
aWindow.dID                          488  0x000001e8 (mem) word (member of aWindow)  (usage 3)
aWindow.lastkey                      490  0x000001ea (mem) word (member of aWindow)  (usage 1)
aWindow.timer                        494  0x000001ee (mem) word (member of aWindow)  (usage 3)
aWindow.timerEvent                   492  0x000001ec (mem) word (member of aWindow)  (usage 3)
aWindow.touchEpoch                   498  0x000001f2 (mem) word (member of aWindow)  (usage 1)
aWindow.touchState                   496  0x000001f0 (mem) word (member of aWindow)  (usage 1)
aWindow.touchX1                      320  0x00000140 (mem) word[12] (member of aWindow)  (usage 1)
aWindow.touchX2                      368  0x00000170 (mem) word[12] (member of aWindow)  (usage 1)
aWindow.touchY1                      344  0x00000158 (mem) word[12] (member of aWindow)  (usage 1)
aWindow.touchY2                      392  0x00000188 (mem) word[12] (member of aWindow)  (usage 1)
aWindow.vButtonActArg                440  0x000001b8 (mem) word[12] (member of aWindow)  (usage 6)
aWindow.vButtonActType               416  0x000001a0 (mem) word[12] (member of aWindow)  (usage 5)
aWindow.vButtonTouchable             464  0x000001d0 (mem) word[12] (member of aWindow)  (usage 4)
aWindow.windowHeight                 312  0x00000138 (mem) word (member of aWindow)  (usage 3)
aWindow.windowWidth                  310  0x00000136 (mem) word (member of aWindow)  (usage 3)
aWindow.xgap                         314  0x0000013a (mem) word (member of aWindow)  (usage 3)
aWindow.xgrid                        318  0x0000013e (mem) word (member of aWindow)  (usage 3)
aWindow.xpos                         306  0x00000132 (mem) word (member of aWindow)  (usage 3)
aWindow.ygap                         316  0x0000013c (mem) word (member of aWindow)  (usage 3)
aWindow.ypos                         308  0x00000134 (mem) word (member of aWindow)  (usage 3)
B_IP                                   0  0x00000000 (const ??? 0)  (usage 1)
BACK                                  98  0x00000062 (const dword)  (usage 3)
BASE_CFG                               0  0x00000000 (const ??? 0)  (usage 3)
baseQueue                            288  0x00000120 (mem) word (global)  (usage 4)
BG_GREY                                1  0x00000001 (const ??? 0)  (usage 1)
BLACK                                  0  0x00000000 (const dword)  (usage 7)
BOARDS_CFG                             1  0x00000001 (const ??? 0)  (usage 3)
boot                                  98  0x00000062 (User func) args[0] r=0  (usage 1)
BOTTOM_ICON                           29  0x0000001d (const ??? 0)  (usage 1)
BTN_OFF                               48  0x00000030 (const ??? 0)  (usage 1)
BUTTON                                98  0x00000062 (const dword)  (usage 2)
CHAR                                   2  0x00000002 (const ??? 0)  (usage 4)
CHARNUM                                6  0x00000006 (const ??? 0)  (usage 10)
CHR                                  129  0x00000081 (const dword)  (usage 18)
COM0                               63492  0x0000f804 (const dword)  (usage 9)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (usage 1)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (usage 1)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (usage 1)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[2] r=0  (usage 1)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (usage 4)
conditionItemA                       192  0x000000c0 (mem) word (global)  (usage 2)
conditionItemB                       196  0x000000c4 (mem) word (global)  (usage 2)
conditionOperator                    194  0x000000c2 (mem) word (global)  (usage 2)
confContainsID                        74  0x0000004aconfContainsID                        74  0x0000004a (mem) word[6] (member of Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts.4DG)  (usage 1)
configControl                        208  0x000000d0 (mem) word[4] (global)  (usage 5)
configModel                          198  0x000000c6 (mem) word[1] (global)  (usage 1)
configView                           200  0x000000c8 (mem) word[4] (global)  (usage 6)
confVectors                          268  0x0000010c (mem) word[6] (global)  (usage 8)
CONTRAST                              25  0x00000019 (const dword)  (usage 3)
controlDev                          4362  0x0000110a (User func) args[2] r=0  (usage 4)
controlRelay                        4266  0x000010aa (User func) args[3] r=0  (usage 4)
createQueue                         5760  0x00001680 (User func) args[1] r=0  (usage 2)
D_BOARD                                0  0x00000000 (const ??? 0)  (usage 1)
dataLen                               25  0x00000019dataLen                               25  0x00000019 (mem) byte[11] (member of Z:\home\matteo\Documenti\Development\ipx800touchpanel\4DGL\IPX800ts.4DG)  (usage 2)
DEC                                 1290  0x0000050a (const dword)  (usage 9)
DEC1                                 266  0x0000010a (const dword)  (usage 4)
DEC2                                 522  0x0000020a (const dword)  (usage 4)
DEC2Z                               4618  0x0000120a (const dword)  (usage 5)
DEVICE                               100  0x00000064 (const dword)  (usage 2)
DEVICE_ICON                           10  0x0000000a (const ??? 0)  (usage 1)
deviceBoard                          166  0x000000a6 (mem) word (global)  (usage 3)
deviceExtra                          172  0x000000ac (mem) word (global)  (usage 5)
deviceIndex                          170  0x000000aa (mem) word (global)  (usage 3)
deviceName                           174  0x000000ae (mem) word (global)  (usage 2)
DEVICES_CFG                            2  0x00000002 (const ??? 0)  (usage 3)
deviceStatus                         176  0x000000b0 (mem) word (global)  (usage 12)
deviceUsage                          168  0x000000a8 (mem) word (global)  (usage 5)
dispatchAction                      4791  0x000012b7 (User func) args[2] r=0  (usage 2)
dispatchMainQueueActions            5158  0x00001426 (User func) args[0] r=0  (usage 1)
dispatchQueueActions                4996  0x00001384 (User func) args[1] r=0  (usage 2)
DOWN_ICON                             27  0x0000001b (const ??? 0)  (usage 1)
executeAction                       4463  0x0000116f (User func) args[2] r=0  (usage 1)
exitfunc                          UNRESOLVED  (usage 1)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (usage 1)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (usage 2)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (usage 1)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (usage 1)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 1)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (usage 1)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (usage 1)
FONT1                                  0  0x00000000 (const dword)  (usage 1)
FONT3                                  2  0x00000002 (const dword)  (usage 1)
GENSTAT                               71  0x00000047 (const dword)  (usage 5)
getALitem                           5179  0x0000143b (User func) args[3] r=0  (usage 4)
getConfArray                        8473  0x00002119 (User func) args[2] r=0  (usage 7)
getConfVect                       UNRESOLVED  (usage 1)
getQactPos                          5542  0x000015a6 (User func) args[2] r=0  (usage 3)
getQdata                            5627  0x000015fb (User func) args[2] r=0  (usage 8)
getType                             8509  0x0000213d (User func) args[2] r=0  (usage 4)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 2)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 3)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (usage 3)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 1)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 8)
GRAY                               33808  0x00008410 (const dword)  (usage 1)
GREEN                               1024  0x00000400 (const dword)  (usage 1)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (usage 5)
HUMID                                104  0x00000068 (const dword)  (usage 2)
HUMIDITYSENS                          38  0x00000026 (const ??? 0)  (usage 1)
iconedButton                        2129  0x00000851 (User func) args[1] r=0  (usage 2)
iconedButton.id                      292  0x00000124 (mem) word (member of iconedButton)  (usage 4)
iconedButton.sensstr                 294  0x00000126 (mem) word[6] (member of iconedButton)  (usage 2)
iconedButton.text                    290  0x00000122 (mem) word (member of iconedButton)  (usage 3)
id                                UNRESOLVED  (usage 33)
img                                 5799  0x000016a7 (User func) args[4] r=0  (usage 10)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (usage 1)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (usage 1)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (usage 1)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (usage 1)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 1)
IMGhndl                              282  0x0000011a (mem) word (global)  (usage 7)
INITIALIZE                             0  0x00000000 (const ??? 0)  (usage 5)
Initialize                        UNRESOLVED  (usage 1)
IO1_PIN                                1  0x00000001 (const dword)  (usage 2)
IP                                     4  0x00000004 (const ??? 0)  (usage 5)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (usage 1)
LANDSCAPE                              0  0x00000000 (const dword)  (usage 1)
lastkey                           UNRESOLVED  (usage 5)
LIGHT                                108  0x0000006c (const dword)  (usage 5)
LIGHT_OFF                             19  0x00000013 (const ??? 0)  (usage 1)
LIGHT_UNKNOWN                         18  0x00000012 (const ??? 0)  (usage 2)
LIGHTX                                76  0x0000004c (const dword)  (usage 2)
loadArduinoConfig                   8418  0x000020e2 (User func) args[1] r=0  (usage 1)
loadBaseConfig                      8348  0x0000209c (User func) args[1] r=0  (usage 1)
loadConfFile                        7051  0x00001b8b (User func) args[2] r=0  (usage 2)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (usage 6)
MAXBUTTONS                            12  0x0000000c (const dword)  (usage 35)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (usage 6)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (usage 1)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (usage 2)
MEMHEAP                               77  0x0000004d (const dword)  (usage 1)
ncLIST                                10  0x0000000a (const ??? 0)  (usage 4)
ncnLIST                                8  0x00000008 (const ??? 0)  (usage 4)
NO                                    24  0x00000018 (const ??? 0)  (usage 3)
NONE                                 110  0x0000006e (const dword)  (usage 1)
NULLSTRING                             7  0x00000007 (const ??? 0)  (usage 5)
nullstring                             0  0x00000000 (mem) word (global)  (usage 6)
NUMBER                                 0  0x00000000 (const ??? 0)  (usage 19)
numVar                               148  0x00000094 (mem) word[9] (global)  (usage 7)
OFF                                    0  0x00000000 (const dword)  (usage 2)
OFFICE_SMALL                          32  0x00000020 (const ??? 0)  (usage 1)
OK                                    31  0x0000001f (const ??? 0)  (usage 4)
ON                                     1  0x00000001 (const dword)  (usage 2)
onShortClick                         952  0x000003b8 (User func) args[2] r=0  (usage 2)
OPAQUE                                 1  0x00000001 (const dword)  (usage 1)
PANEL_RAISED                           1  0x00000001 (const dword)  (usage 1)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (usage 2)
parseStatus                         3753  0x00000ea9 (User func) args[0] r=0  (usage 1)
parseStatusLine                     3559  0x00000de7 (User func) args[1] r=0  (usage 1)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 4)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (usage 1)
PICASO                                 1  0x00000001 (const dword)  (usage 1)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (usage 1)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (usage 1)
pingArduino                         6130  0x000017f2 (User func) args[0] r=0  (usage 1)
pingCNT                              284  0x0000011c (mem) word (global)  (usage 4)
placeWindow                         1941  0x00000795 (User func) args[10] r=0  (usage 2)
PLUG_OFF                              16  0x00000010 (const ??? 0)  (usage 1)
PLUG_UNKNOWN                          15  0x0000000f (const ??? 0)  (usage 1)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (usage 13)
preparePopUp                        1912  0x00000778 (User func) args[2] r=0  (usage 1)
prepareWindow                       2030  0x000007ee (User func) args[1] r=0  (usage 4)
PULSE                                112  0x00000070 (const dword)  (usage 2)
PULSE_ICON                            22  0x00000016 (const ??? 0)  (usage 1)
PULSERELAY                             3  0x00000003 (const dword)  (usage 2)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (usage 2)
putConfig                           6178  0x00001822 (User func) args[0] r=0  (usage 1)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (usage 1)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 5)
q_ACTIVEPOS                            2  0x00000002 (const ??? 0)  (usage 7)
q_CURITEM                              0  0x00000000 (const ??? 0)  (usage 3)
q_FORCEDEV                             1  0x00000001 (const ??? 0)  (usage 1)
q_SCENARIO                             4  0x00000004 (const dword)  (usage 3)
q_sCONDITION                           5  0x00000005 (const ??? 0)  (usage 2)
q_sTYPE                                4  0x00000004 (const ??? 0)  (usage 2)
queueGenScenario                    5342  0x000014de (User func) args[4] r=0  (usage 2)
queueScenario                       5464  0x00001558 (User func) args[2] r=0  (usage 6)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (usage 2)
reboot                              6104  0x000017d8 (User func) args[0] r=0  (usage 1)
RED                                63488  0x0000f800 (const dword)  (usage 1)
REFRESH                               25  0x00000019 (const ??? 0)  (usage 1)
rxBuf                                 42  0x0000002a (mem) word[45] (global)  (usage 1)
SAVE                                  33  0x00000021 (const ??? 0)  (usage 2)
SBOTTOM                           1204224  0x00126000??? SBOTTOM                            string SYM_SET   (usage 1)
Scan                              UNRESOLVED  (usage 1)
SCAN                                   2  0x00000002 (const ??? 0)  (usage 3)
SCEN1                                 13  0x0000000d (const ??? 0)  (usage 1)
SCENARIO                             115  0x00000073 (const dword)  (usage 2)
scenarioActList                      190  0x000000be (mem) word (global)  (usage 4)
scenarioConf                         188  0x000000bc (mem) word (global)  (usage 3)
scenarioName                         186  0x000000ba (mem) word (global)  (usage 2)
SCENARIOS_CFG                          5  0x00000005 (const ??? 0)  (usage 2)
screenOn                            6588  0x000019bc (User func) args[0] r=0  (usage 2)
screensaver                         5905  0x00001711 (User func) args[0] r=0  (usage 1)
screenSaverActive                    286  0x0000011e (mem) word (global)  (usage 5)
SCRSAVER_TIMEOUT                       0  0x00000000 (const ??? 0)  (usage 1)
SCRSAVER_UPD_INTV                      1  0x00000001 (const ??? 0)  (usage 1)
SDOWN                             1138536  0x00115f68??? SDOWN                              string SYM_SET   (usage 1)
search                              4383  0x0000111f (User func) args[5] r=0  (usage 1)
SENSORS                               14  0x0000000e (const ??? 0)  (usage 1)
sensstr                           UNRESOLVED  (usage 3)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (usage 1)
setALitem                           5258  0x0000148a (User func) args[4] r=0  (usage 3)
setQactPos                          5480  0x00001568 (User func) args[3] r=0  (usage 1)
setQdata                            5575  0x000015c7 (User func) args[3] r=0  (usage 4)
setTimer                            6694  0x00001a26 (User func) args[3] r=0  (usage 5)
SHUTTER                              115  0x00000073 (const dword)  (usage 5)
SHUTTER_ICON                          30  0x0000001e (const ??? 0)  (usage 2)
SKIP                                   5  0x00000005 (const ??? 0)  (usage 5)
SLEEP_TIMEOUT                          2  0x00000002 (const ??? 0)  (usage 1)
sleepMode                           6683  0x00001a1b (User func) args[0] r=0  (usage 1)
STAT_ON                               37  0x00000025 (const ??? 0)  (usage 1)
STAT_UNKNOWN                          35  0x00000023 (const ??? 0)  (usage 2)
STATUS_PARSE_INTV                      2  0x00000002 (const ??? 0)  (usage 1)
STOP                              1204200  0x00125fe8??? STOP                               string SYM_SET   (usage 1)
storeFunction                        280  0x00000118 (mem) word (global)  (usage 3)
storeRAMConfLine                    7493  0x00001d45 (User func) args[3] r=0  (usage 1)
STR                                  128  0x00000080 (const dword)  (usage 2)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (usage 15)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (usage 2)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (usage 4)
str_GetWZ                           6966  0x00001b36 (User func) args[2] r=0  (usage 16)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (usage 9)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (usage 17)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (usage 14)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (usage 3)
STRING                                 1  0x00000001 (const ??? 0)  (usage 10)
SUP                               1138512  0x00115f50??? SUP                                string SYM_SET   (usage 1)
SWITCHRELAY                            2  0x00000002 (const dword)  (usage 1)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (usage 6)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 6)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (usage 8)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (usage 2)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (usage 2)
TEMP                                 116  0x00000074 (const dword)  (usage 2)
TEMPERATURESENS                       21  0x00000015 (const ??? 0)  (usage 2)
TEMPX                                 84  0x00000054 (const dword)  (usage 2)
testCondition                       3860  0x00000f14 (User func) args[1] r=0  (usage 3)
text                              UNRESOLVED  (usage 13)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (usage 3)
TEXT_COLOUR                            0  0x00000000 (const dword)  (usage 6)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (usage 2)
TEXT_OPACITY                           8  0x00000008 (const dword)  (usage 1)
TEXT_WIDTH                             3  0x00000003 (const dword)  (usage 2)
TIME                                  72  0x00000048 (const dword)  (usage 1)
time                                 140  0x0000008c (mem) word[3] (global)  (usage 9)
timer                             UNRESOLVED  (usage 1)
TIMER0                                 0  0x00000000 (const dword)  (usage 1)
TIMER1                                 1  0x00000001 (const dword)  (usage 3)
TIMER2                                 2  0x00000002 (const dword)  (usage 3)
TIMER4                                 4  0x00000004 (const dword)  (usage 2)
TIMER5                                 5  0x00000005 (const dword)  (usage 2)
TIMER7                                 7  0x00000007 (const dword)  (usage 2)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (usage 9)
TOP_ICON                              28  0x0000001c (const ??? 0)  (usage 1)
touch                               6868  0x00001ad4 (User func) args[0] r=0  (usage 2)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 1)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 4)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 1)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 1)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 2)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 1)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 1)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 2)
touchEpoch                        UNRESOLVED  (usage 2)
touchMSG                            6888  0x00001ae8 (User func) args[1] r=0  (usage 1)
touchState                        UNRESOLVED  (usage 3)
touchX1                           UNRESOLVED  (usage 6)
touchX2                           UNRESOLVED  (usage 2)
touchY1                           UNRESOLVED  (usage 5)
touchY2                           UNRESOLVED  (usage 3)
TRANSPARENCY                          21  0x00000015 (const dword)  (usage 4)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (usage 1)
trigger                             5866  0x000016ea (User func) args[0] r=0  (usage 1)
TRIGGER_TEST_INTV                      3  0x00000003 (const ??? 0)  (usage 3)
TURNOFFRELAY                           0  0x00000000 (const dword)  (usage 2)
TURNONRELAY                            1  0x00000001 (const dword)  (usage 2)
txBuf                                  2  0x00000002 (mem) word[20] (global)  (usage 1)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (usage 2)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (usage 2)
UNUMBER                                9  0x00000009 (const ??? 0)  (usage 2)
UP_ICON                               26  0x0000001a (const ??? 0)  (usage 1)
Update                            UNRESOLVED  (usage 2)
UPDATE                                 1  0x00000001 (const ??? 0)  (usage 1)
updateDevice                        3342  0x00000d0e (User func) args[4] r=0  (usage 1)
vButtonTouchable                  UNRESOLVED  (usage 3)
vect_base                            216  0x000000d8 (mem) word[3] (global)  (usage 4)
vect_boards                          222  0x000000de (mem) word[2] (global)  (usage 1)
vect_conditions                      242  0x000000f2 (mem) word[3] (global)  (usage 4)
vect_devices                         226  0x000000e2 (mem) word[5] (global)  (usage 6)
vect_scenarios                       248  0x000000f8 (mem) word[4] (global)  (usage 4)
vect_size                            256  0x00000100 (mem) word[6] (global)  (usage 3)
vect_windows                         236  0x000000ec (mem) word[3] (global)  (usage 4)
VOLTAGE                               86  0x00000056 (const dword)  (usage 2)
VOLTSENS                              39  0x00000027 (const ??? 0)  (usage 1)
W_WIDGETLIST                           2  0x00000002 (const ??? 0)  (usage 1)
WHITE                              65535  0x0000ffff (const dword)  (usage 5)
WIN_UPD_INTV                           3  0x00000003 (const ??? 0)  (usage 2)
WINDOW                               119  0x00000077 (const dword)  (usage 3)
WINDOW_COLOR                       65535  0x0000ffff (const dword)  (usage 4)
WINDOW_PATH                            3  0x00000003 (const dword)  (usage 2)
windowHeight                      UNRESOLVED  (usage 1)
windowIcon                           180  0x000000b4 (mem) word (global)  (usage 2)
windowName                           178  0x000000b2 (mem) word (global)  (usage 2)
WINDOWS_CFG                            3  0x00000003 (const ??? 0)  (usage 1)
windowUpdate                        3333  0x00000d05 (User func) args[0] r=0  (usage 1)
windowWidgetList                     182  0x000000b6 (mem) word (global)  (usage 1)
windowWidth                       UNRESOLVED  (usage 1)
WORD                                   3  0x00000003 (const ??? 0)  (usage 4)
wPath                                132  0x00000084 (mem) word[3] (global)  (usage 3)
wPathNum                             138  0x0000008a (mem) word (global)  (usage 6)
wPop                                8618  0x000021aa (User func) args[0] r=0  (usage 4)
wPush                               8644  0x000021c4 (User func) args[1] r=0  (usage 4)
xgap                              UNRESOLVED  (usage 2)
xgrid                             UNRESOLVED  (usage 2)
xpos                              UNRESOLVED  (usage 2)
ygap                              UNRESOLVED  (usage 1)
ypos                              UNRESOLVED  (usage 3)
